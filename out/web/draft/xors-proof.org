#+title:  parity proofs

* definitions
:PROPERTIES:
:TS:       <2015-01-24 11:03PM>
:ID:       3bb8lxn0sqg0
:END:

** Bit Vector
*n*. A vector where each element is either 0 or 1.
#+begin_src J
  and =: *.
  all =: and/
  rank =: #@$
  isVec =: 1 = rank
  allBits =: 0 1 e.~ ,
  isBitV =: isVec and allBits
#+end_src

** =BV n= the set of all bit vectors of length =n=.
For =n>0=, can be generated by counting from =0= to =(2^n)= in binary.
#+begin_src J
  BV =: (1 0 $ 0) if (0=]) else ([: #: [: i. 2 ^ ])
#+end_src

=BV 0= contains the empty bit vector, =(1 0 $ 0)=.
=BV 1= contains the two vectors, =(,0)= and =(,1)=.
=BV 2= contains =(0 0)=, =(0 1)=, =(1 0)=, and =(1 1)=.
etc.


** ={.= head
The first element of an array. e.g., =({. 2 3 5) = 2=

** =}.= behead
Returns the array without its head. e.g., =(}. 2 3 5) = 3 5=

(People familiar with list-based languages often expect this to be called the /tail/, but that word refers to the last element of the array: remember that lists are either the special value /null/, or arrays of length 2, where the tail is also a list.)

** =B0V n= the subset of =BV n= where the leftmost bit is 0.

** =B1V n= the subset of =BV n= where the leftmost bit is 1.

** Endomorphism
A mapping from a mathematical structure back to itself.

** =xors= xor scan
1. *v*. The process of inserting the xor verb between each item of each successive prefix of an array, and evaluating the results.
2. *n*. The result of this process.

#+begin_src J
  xors =: ~:/\ "1
#+end_src

** =lp2= least power of 2 (of real number /n/)
*n*. The least power of 2 greater than or equal to =n=. If =p= is the base 2 logarithm of =n= rounded upward to the next whole number, then =lp2 n= is =2^p=.

#+begin_src J
  lp2 =: >. &. (2 & ^.)
  (,:lp2) i.16
0 1 2 3 4 5 6 7 8  9 10 11 12 13 14 15
0 1 2 4 4 8 8 8 8 16 16 16 16 16 16 16
#+end_src

** power of a function (denoted =f^: p=, where =p= is an integer.)
:PROPERTIES:
:TS:       <2015-01-25 03:23AM>
:ID:       1gu9zxz0sqg0
:END:
The process (or result) of applying a function recursively =p= times.
For example, =f^:0 y= means =y=, while =f^:2 y= means =(f (f 5))=.

If =p= is negative, then the inverse of =f= is applied =-p= times. Clearly, this is only defined when the inverse of =f= itself is defined.

** =cyclen= cycle length (period) of an endomorphism for some value
:PROPERTIES:
:TS:       <2015-01-25 04:01AM>
:ID:       8jr4cq11sqg0
:END:
This describes how many iterations of the endomorphism must be applied before arriving back at the original value.

If =1 = f cyclen y=, then y is a /fixed point/ of f.



* alternate (inductive) definition of =BV n= for =n > 0=
:PROPERTIES:
:TS:       <2015-01-25 07:39AM>
:ID:       z66httb1sqg0
:END:

Let =osBV= and =lsBV= (mnemonics: 0 stich boolean vector, 1 stitch...) be functions that append the numbers 0 and 1 (respectively) to each row of an array:

#+begin_src J
  osBV =: 0,.]
  lsBV =: 1,.]
#+end_src

Define the constant =eBV= to be an array containing the 0-bit array of bits.

#+begin_src J
  eBV =: (1 0 $0)
#+end_src

Now we can create a recursive function to define =BV n= inductively:

#+begin_src J
  load'syntax.ijs'
  rBV =: eBV if (0=]) else ([: (osBV,lsBV) [: $: ]-1:)
#+end_src

This returns =eBV= when =n=0=, and otherwise returns =((osBV,lsBV) rBV (n-1))=.

#+begin_src J
     rBV 0

     rBV 1
  0
  1
#+end_src

So to prove a statement =P= about all boolean vectors, we just have to follow three steps:

1. Show =P(BV 0)=. That is, show =P(eBV)=.
2. Show that =P(BV n)= implies =P(osBV BV n)=.
3. Show that =P(BV n)= implies =P(lsBV BV n)=.

Froms steps 2 and 3, you can show show that =P(BV n)= implies =P(BV n+1)=. Thus, together, the steps prove =∀n:Nat. P(BV n)=.


* theorem: =xs ^:p v= for (=v e. B1V n=) cycles with period =lp2 n=.
:PROPERTIES:
:TS:       <2015-01-24 11:28PM>
:ID:       bis4c2p0sqg0
:END:

** TODO 1. =(isBitV v)= → =(# xors v) = (# v)=
:PROPERTIES:
:TS:       <2015-01-24 11:48PM>
:ID:       jkscpzp0sqg0
:END:
(I'll need to formally define scans to prove this, then it's trivial because the length of the input is equal to the length of the output for /any/ scan.)

** TODO 2. =(isBitV v)= → =(isBitV xors v)=
Formally define xor for booleans, then:
This follows from lemma 1 and the definitions of =xors= and =xor=.

** 3. Thus =xors= is an endorphism on =BV n=.

** TODO 4. There are at exactly =2^n= distinct bit vectors of length =n=.
:PROPERTIES:
:TS:       <2015-01-24 11:58PM>
:ID:       k2b5ngq0sqg0
:END:
This should also be easy to prove, because =BV n= maps directly to the numbers =i.2^n= in binary.

** TODO 5. The period of any iterated endomorphism on =BV n= must be ≤ =2^n=.
:PROPERTIES:
:TS:       <2015-01-25 12:06AM>
:ID:       zuld5vq0sqg0
:END:
Keep applying a mapping from =BV n= to =BV n=, and eventually you will run out of distinct bit vectors.

Generalization: a similar thing can be said of any endmorphism on any finite set of objects.

** 6. Thus =xors^:p v=, where =v e. BV n=, is cyclic with period ≤ =2^n=.
:PROPERTIES:
:TS:       <2015-01-25 12:52AM>
:ID:       plifvys0sqg0
:END:
This gives us an upper bound, but we can do much better.

** TODO 7. ∀ =a= ∈ Nat ∀ =v= ∈ (BV n) ⋅ =(xors (a$0),v) -: (a$0),xors v)=
:PROPERTIES:
:TS:       <2015-01-25 01:21AM>
:ID:       up58ibu0sqg0
:END:
This says that appending zeros to the left side of a bit vector and then taking the xor scan is the same as taking the xor scan of the vector and then appending zeros to the left side of the result.

This follows from the fact that 0 is the identity element for xor over booleans.

Examples:

#+begin_example J
   xors each 1 ; 0 1
┌─┬───┐
│1│0 1│
└─┴───┘
   xors each 1 0 ; 0 1 0
┌───┬─────┐
│1 1│0 1 1│
└───┴─────┘
#+end_example


** 8. =eBV= is a fixed point of =xors=. i.e., (=1 = xors cyclen eBV=)
:PROPERTIES:
:TS:       <2015-01-25 08:04AM>
:ID:       bsajhyc1sqg0
:END:

#+begin_src s
   (eBV)-:xors eBV
1
#+end_src

** 8. =(,0)= (the first member of =BV 1=) is a fixed point of =xors=.
:PROPERTIES:
:TS:       <2015-01-25 04:57AM>
:ID:       k6c0wb41sqg0
:END:
Proof by demonstration:

#+begin_src J
   (,0) -: xors (,0)
1
#+end_src

** 9. =(,1)= (the second member of =BV 1=) is also a fixed point of =xors=.
:PROPERTIES:
:TS:       <2015-01-25 05:02AM>
:ID:       z4gc8k41sqg0
:END:
Again, by example:

#+begin_example J
   (,1) -: xors (,1)
1
#+end_example

** 10. Thus =v= is a fixed point of =xors= for all =v= in =BV 1=
:PROPERTIES:
:TS:       <2015-01-25 05:03AM>
:ID:       zwg1al41sqg0
:END:






** TODO ??. =xors cyclen v= where =v e. B0V n= is equal to =xors cyclen }. v=
:PROPERTIES:
:TS:       <2015-01-25 03:18AM>
:ID:       di6kqpz0sqg0
:END:



* TODO the plan
:PROPERTIES:
:TS:       <2015-01-25 09:54AM>
:ID:       ltw51i30tqg0
:END:
I guess the basic line of attack here is to show that =osBV= doesn't increase the cycle length. This means that when you add a new bit, half the search space still has the old cycle length.

=xors= over =BV 1=  has 2 cycles of length 1.

=xors= over =BV 2= maintains the 2 cycles of len 1, and adds two cycles of length 2.

=xors= over =BV 3= maintains the previous 4 cycles, and adds 4 cycles of length 4.

Then we have to talk about =lsBV=.

