#+title: b4i macro and interactive commands test suite
#+tanco-format: 0.2

* About this file
This file demonstrates the macro and interactive commands.
Currently these interactive features are present only in
the lil implementation (`mb4.deck`). The macros are also
available in the pascal version's assembler.

* TEST b4i.bug.mlatu : bug: b4i treated first two chars as opcode
#+begin_src b4a
  > :mlatu rt
  > 2 3 mlatu ?d %q
  ds: [2 3]
#+end_src

* TEST b4i.addr : Interactive assembler: assemble to any address
#+begin_src b4a
  > :100 ^A ^B
  > ?100
  ^A ^B .. .. .. .. .. .. .. .. .. .. .. .. .. ..
  > :104 ^C ^D
  > ?100
  ^A ^B .. .. ^C ^D .. .. .. .. .. .. .. .. .. ..
  > :100 ^X ^Y
  > ?100
  ^X ^Y .. .. ^C ^D .. .. .. .. .. .. .. .. .. ..
  > ?104
  ^C ^D .. .. .. .. .. .. .. .. .. .. .. .. .. ..
#+end_src

* TEST b4i.invoke : invoke register
# Original headline: invoke word via the "register dictionary"

#+begin_src b4a
> :A lb 'a lb 'e io rt
> :B lb 'b lb 'e io rt
> ?A
00000100
> ?B
00000106
> ^A ^B %q
ab
#+end_src

using ^ with a register name should trigger the register




* TODO comments

this doesn't work because the old test parser can't andle the "#"

# #+name: comments
# #+begin_src b4a
# > # this is a comment
# > 01 # 02
# > ?d
# ds: [1]
# = comments
# : comments start with '#' and everything until the end of line is ignored
# #+end_src

* Macros
** TEST macro.if-else-then : if/else/then macro
# Original headline: .i .e .t (if/else/then)
#+begin_src b4a
> :E lb 'e io rt
> :T c1 .i lb 'T ^E .e lb 'F ^E .t rt
> ^T %q
T
#+end_src

if the top of the stack is non-zero, execute the first block
otherwise, execute the second block

** TEST macro.while-do : while/do macro
# Original headline: .w .d .o (while/do)
#+begin_src b4a
> :E lb 'e io rt
> :T lb 'a !A lb 03 .w du .d c1 +A ^E c1 sb .o rt
> ^T %q
abc
#+end_src

while the top of the stack is non-zero, execute the block
decrement the top of the stack each iteration

** TEST macro.for-next : for/next macro
# Original headline: .f .n (for/next)
#+begin_src b4a
> :E lb 'e io rt
> :T lb 03 .f cd du dc lb 'a ad ^E .n rt
> ^T %q
dcb
#+end_src

execute the block a fixed number of times
the counter is stored on the control stack

** TEST macro.linked-list : .^ : linked list
# Original headline: .^ (linked list)
#+begin_src b4a
> :100 .^ .^ .^ .^
> ?100 %q
.. .. .. .. .. ^A .. .. ^D ^A .. .. ^H ^A .. ..
#+end_src

creates a linked list in little endian format
each node points to the previous node's address.
The first four bytes are the null value `0x00`,
then `0x100` (`00 01 00 00` in little endian format).
then `0x104` (`04 01 00 00` in little endian format).
then `0x108` (`08 01 00 00` in little endian format).

* interactive get/set for labels

** TEST b4i.getset : get/set (b4i)
#+begin_src b4a
  > :int 04 03 02 01
  > @int ?d
  ds: [1020304]
  > zp 5 !int ?d
  ds: []
  > @int ?d %q
  ds: [5]
#+end_src

* Interactive Commands

** TEST interactive.reset : %R : reset the virtual machine
# Original headline: %R (reset)
#+begin_src b4a
> 01 02 03 ?d %R ?d %q
ds: [1 2 3]
ds: []
#+end_src

resets the stacks and sets ip to 100.
does not clear memory.

** TEST interactive.clear : %C : clear the virtual machine
# Original headline: %C (clear)
#+begin_src b4a
> 01 02 03 ?d %R ?d %q
ds: [1 2 3]
ds: []
#+end_src

clears the stacks and resets memory

** TEST b4i.label : `label : use label
# Original headline: `label (use label)
#+begin_src b4a
  > :lbl 'a 'b 'c 'd
  > : li `lbl rt
  > ?lbl
  00000100 +A +B +C +D li .. ^A .. .. rt .. .. .. .. .. ..
  > `lbl ?d %q
  ds: [100]
#+end_src

pushes the address of the label onto the stack

** TEST b4i.hexname : edge case: names that are also lowercase hex numbers
#+begin_src b4a
  > :def 'a 'b 'c 'd
  > : li `def rt
  > ?def
  00000100 +A +B +C +D li .. ^A .. .. rt .. .. .. .. .. ..
  > `def ?d
  ds: [100]
#+end_src

*** TEST interactive.show-memory : ?m : show memory
# Original headline: ?m (show memory)
#+begin_src b4a
> :100 01 02 03 04 'h 'e 'l 'l 'o
> ?100 %q
^A ^B ^C ^D +H +E +L +L +O .. .. .. .. .. .. ..
#+end_src

displays the contents of memory starting at the specified address

* TEST bug.c.clears.dictionary : bug: %C should clear the dictionary
#+begin_src b4a
> :foo rt
> \p
0100:foo
> %C
> \p
> %q
#+end_src

* TODO: Additional tests for other macros and interactive commands
** %e (run to end)
##+name: interactive.run-to-end
##+begin_src b4a
= %e : run to end
: executes instructions until a return is encountered
##+end_src

** %\ (goto)
##+name: interactive.goto
##+begin_src b4a
= %\ : goto
: jumps to the address stored in the "@\" register
##+end_src

** string literals
*** TEST b4a.string.raw : ="abc"= : raw string
#+begin_src b4a
> :100 "abc def"
> ?100 %q
+A +B +C @@ +D +E +F .. .. .. .. .. .. .. .. ..
#+end_src

*** TEST b4a.string.len-prefixed : =."abc"= : length-prefixed string
#+begin_src b4a
> :100 ."abc def"
> ?100 %q
^G +A +B +C @@ +D +E +F .. .. .. .. .. .. .. ..
#+end_src

** TEST b4a.fwd : Using =>= for forward references
#+begin_src b4a
  > :A cl >foo rt
  > \f
  0101>foo
  > :foo c2 n1 rt
  > \f
  > ^A ?d %q
  ds: [2 -1]
#+end_src

Inside the assembler, you can use the =>= prefix to indicate a word
that is to be defined later. Note that unlike a bare word, this does
not assemble an implicit =cl= so you must write it manually.

Meanwhile, the =\f= command can be used to inspect forward references
that have not yet been filled in.

** TEST b4a.u32 : =$= for u32 hex values
#+begin_src b4a
> :100 lb C0 li $AA .. lb C1 li AA .. .. .. ..
> ?100
lb c0 li AA .. .. .. .. lb c1 li AA .. .. .. ..
> : lb C2 li $01020304 rt
> ?110
lb C2 li ^D ^C ^B ^A rt .. .. .. .. .. .. .. ..
#+end_src

Using =$= in front of a number makrs
