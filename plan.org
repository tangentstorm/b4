#+title: b4 implementation plan

* TODO pas: include bios in the executable
* TODO pas: flags to configure loading bios

* DONE get a string match working
* DONE show labels in the debugger
- defs could always be line-aligned (just leave spaces)
  and we could have a comment on the left
* DONE read/write individual bytes
    rb/wb
    ri/wi

    -- stacks and registers are all 32 bits
    -- but the main content can be bytes

    --  READ byte VS READ value (4 bytes) --
    -> s-eq? wants to read a byte at a time
    -> eol flag could just be a byte.

    -- but: we also want to write registers
* DONE implement number parser
* DONE implement number printer
* DONE [3/3] bring turbo vm in sync with j version
** DONE use the new 2-char b4 opcodes
** DONE allow character literals with 'x
** DONE fix the existing bios

* DONE add !var and @var to assembler

* TODO [3/4] make the debug display easier to see
** DONE explicit 'call' op
** DONE use high bits for ops
** DONE switch ram to bytes
* TODO memory allocator
* TODO add dictionary entries for all non-control-flow ops
* TODO b4a repl
you should be able to execute assembly language instructions directly
(in the vm implementation itself)
- maybe even show exactly how it's getting assembled underneath
- run opcodes directly
- show stacks
- show ram

* TODO [2/4] implement the forth interpreter
** DONE [4/4] implement a forth-style dictionary
*** DONE implement headers manually
*** DONE implement 'words'
*** DONE implement 'word?' (s-a)
- find definition
  - get last entry address
  - while entry address != 0 do:
    - use offset to find string
    - compare entry to goal string
    - if match, then leave address of value on stack
  - if entry = 0, say 'not found'

** DONE interpreter word (exec)
** TODO complier words
- if compiling:
  - write 'call' + address
** TODO defining words
*** ':' defines new word
  - creates new entry
  - reads token for name
  - copies token to heap
  - turns on the compiler
*** ';' emits return and turns off the compiler

*** dictionary entry format
  - prev: addr
  - hash: (optional single cell with 32-bit hash/crc)
  - word: str with len
  - data: the data or value
*** create new entry:
  - last @ ,
  - here @ last !
  # - $goal hash ,
  - str,

*** 'str,' copies a string
  - args: start, length
  - duplicate and write the length
  - copy the string

*** copy tokens to token buffer
- read name
- write name
* TODO read tokens from input buffer instead of keyboard
* TODO macros for dictionary entries
maybe .xxx is label
and   :xxx is dictionary entry?

* TODO have assembler use si, hop, h0 if possible
stacks are still cell-based

* TODO use hex numbers only in turbo b4a
* DONE [2/2] add 'step over', 'run to cursor' in debugger
- [X] 'step over' is only for calls.
  just move the cursor to the next active cell, and then 'run to cursor'
- [X] 'run to cursor' should move to next active cell, and then sets a breakpoint

* DONE show name for calls
[ ] show the label

* TODO show a prettier version of the return stack (with labels)
[ ] show a stack somewhere

* assembler plan
- b4a should extend b3a with:
  - labels
  - special control words ( { } | [ ]  .data .code )
  - call and $addr syntax
- eventually, write b4a in b3a

* b4a spec [runs on the b4 vm, so has a stack, etc]
- immediate need: dictionary
- adds labels
- allow both decimal and hex numbers
- =.data= to allow building raw binary data
  - counted strings
- =.code= to make it nice to write forth-like code
  - auto-call functions
  - add 'si' or 'li' before chars, numbers
- =.dict= to define a dictionary entry
- structured programming constructs:
  - .if .th .el .ef .en
  - .wh .do .od
  - .fr .nx

* what's the presentation here?
** operations on state: simple calculator
- visual 'buttons' that do the work
- number buttons: multiply by base and add digit
- clear, inc, dec?

** sequence:
*** visual virtual machine
*** no-op, breakpoints
(so we can see the cursor moving)
*** place opcodes in the cells directly

** repetition:
- simple counter
- implement addition, multiplication

** conditionals
- show jumping over some code
- show 'else' using [a?] [b?] [c?] [d?]
- so consider this instead: [ c ? a | b ]
- now:
  [ c0 ? a | [ c1 ? b ] ]
- so just allow 'elif'

* TODO edit the input buffer directly
* TODO introduce an enum type for the ops
* TODO allow setting breakpoints
* TODO source-level assembly language debugger

* the interpreter (b4i)
** TODO look up and execute a single word

- last
- e-nm ("lb 4 ad")
- s-eq uses "inc" ("lb 1 ad")
- find (currently "word?")

** TODO number/base
** TODO quote
** TODO repeatedly load tokens from input buffer
** TODO line editor
** TODO "calculator mode" (send ascii chars)
- copy input bytes to buffer
- let enter trigger word

* -- ancient tasks from retro days --
** DONE [2/2] get the basic retro listener to run correctly
*** DONE [4/4] trace retro.py at each step and bring pascal in line
**** DONE retro.py : allow running step by step
**** DONE run the python and pascal vm's side by side
**** DONE ng.pas : trace to logfile with same format
**** DONE fix the discrepancies
*** DONE [4/4] fix the cursor and color handling for extended console
**** DONE position cursor on clrscr
**** DONE position cursor on newline
**** DONE implement colors
** TODO [3/4] fill in the retro vm details                     :pas:
*** DONE load the image (machine code) into an array

Will just do this by hand for now, like I did with javascript, and worry about files when I build the assembler.

I figured using a set type would be cleaner, since it numbers implicitly but now I have to cast everything back to a number because we're mixing them with plain integers.

Probably cleaner would just be to use a file. :)

#+name: machine-code
#+begin_src delphi

  const ram : array [ 0 .. 25 ] of int32 = (

      // set color to red : 4 1 6 out wait ;
      oLIT, 4,                    //  0  1
      oLIT, 1,                    //  2  3
      oLIT, 6,                    //  4  5
      oOUT, oWAIT,                //  6  7

      // draw a pixel
      // : 320 200 2 6 out wait ;
      oLIT, 320,                  //  8  9
      oLIT, 200,                  // 10 11
      oLIT, 2,                    // 12 13
      oLIT, 6,                    // 14 15
      oOUT, oWAIT,                // 16 17

      // write 0 to port 3 to force video update.
      oLIT, 0,                    // 18 19
      oLIT, 3,                    // 20 21
      oOUT, oNOP,                 // 22 23

      oNOP, oNOP                  // 24 25

  );

#+end_src
*** DONE load the image from disk
*** DONE add ability to halt the program
*** TODO [0/2] check that we do these the ngaro way
**** TODO when does ngaro actually do on over/underflow checks?
**** TODO would nos really trigger underflow?
** TODO [4/9] implement io devices                             :easy:
*** DONE port 1 : keyboard
*** DONE port 2 : character generator
*** TODO extend character generator with ability to change bitmap font
*** DONE port 3 : force video update ( optional and not needed here )
*** TODO [10/10] port 4 : file i/o
**** DONE io op  1 | ...               -> 0      | save image
**** DONE io op  2 | filename          -> 0      | include a file
**** DONE io op -1 | filename, mode    -> handle | Open a file
**** DONE io op -2 | handle            -> flag   | Read a byte from a file
**** DONE io op -3 | character, handle -> flag   | Write a byte to a file
**** DONE io op -4 | handle            -> flag   | Close a file
**** DONE io op -5 | handle            -> offset | Return current location in file
**** DONE io op -6 | offset, handle    -> flag   | Seek a new location in file
**** DONE io op -7 | handle            -> size   | Return the size of a file
**** DONE io op -8 | filename          -> flag   | Delete a file.
*** TODO [0/1] port 5 : vm query
**** TODO query op 10 | implement environment variables
http://www.freepascal.org/docs-html/rtl/sysutils/getenvironmentvariable.html
*** TODO [0/8] port 6 : canvas
**** TODO [#A] figure out the basic sdl / aggpas / ptckvm pipeline.
- https://github.com/badsector/ptckvm
- http://www.freepascal-meets-sdl.net/

**** TODO canvas op  1 | n-    | set color for drawing operations
**** TODO canvas op  2 | xy-   | draw a pixel at coordinates x, y
**** TODO canvas op  3 | xyhw- | rectangle
**** TODO canvas op  4 | xyhw- | filled rect
**** TODO canvas op  5 | xyh-  | draw a vertical line of height (h) starting at x, y
**** TODO canvas op  6 | xyw-  | draw a horizontal line of width (w) starting at x, y
**** TODO canvas op  7 | xyw-  | draw a circle of width (w) starting at x, y
**** TODO canvas op  8 | xyw-  | draw a filled circle of width (w) starting at x, y
*** TODO [0/2] port 7 : mouse
**** TODO mouse op 1 | push mx, push my
**** TODO mouse op 2 | push mb ( button state : 1 bit per button )
*** DONE port 8 : enhanced text output

** --- testing ---
** TODO [2/5] implement an assembler
*** DONE export binary numbers padded to proper size
*** DONE implement enough of minno to allow in-band debug signals
*** TODO only show debug messages when given a flag
*** TODO escape the control codes in the output in debug mode
*** TODO allow defining aliases up front in a table
** TODO [0/1] show user-defined words in the debugger
*** TODO procedure to walk the dictionary and extract details
**** COMMENT Crc said that positon 2 in the image is the pointer to "last"
(the address of the last defined word, from which you can follow the links back to get the others.)

See file:~/vrx/doc/Commentary.txt
and file:~/vrx/examples/autopsy.rx
# ( ~/vrx is just my retroforth working copy )

**** TODO define a record structure to hold the word
**** TODO populate the fields
** TODO set up fpcunit so i have a real test suite
** TODO [0/12] exercise vm with more ngaro assembly programs
*** TODO square : draw a square                               :nga:
*** TODO color  : draw the palette                            :nga:
*** TODO click  : click screen to change color                :nga:
*** TODO keys   : press any key to change color               :nga:
*** TODO hello  : show the word hello                         :nga:
*** TODO caps   : letters on screen (uppercase)               :nga:
*** TODO shift  : captital letters / shift key                :nga:
*** TODO color  : colored text input                          :nga:
*** TODO read   : read a file from disk                       :nga:
*** TODO write  : write a file to disk                        :nga:
*** TODO port pixel.hex to pixel.nga
**** NOTE Just use the syntax retro gives when you type =see=
#+begin_example
Retro 11.0 (1309798464)

ok  see ok
1423 nop
1424 nop
1425 lit   4
1427 @
1428 call  167
1429 0;
1430 drop
1431 call  421
1432 lit   54
1434 call  443
1435 ;

ok

#+end_example

** TODO memory manager to allow sharing pascal and retro data
:PROPERTIES:
:TS:       <2012-10-30 04:04AM>
:ID:       mky1x9405xf0
:END:
#+begin_src pascal
{  todo : custom memmory manager
  http://www.freepascal.org/docs-html/prog/progsu160.html#x205-2180008.4.4
}

{ retro's file format conventions ( see image/kernel.rx in retro source ) }
  type rx_header = class
		     prev, wordclass : int32;
		     docptr : ^ansistring;
		     xt     : ^ansistring; { h.xt = @h.code }
		     token  : ansistring;
		     code   : ansistring;
		   end;
  const
    rx_last  = 2;
    rx_xtofs = ;

#+end_src
** --- cross-platform ---
** TODO [0/3] bugs in other ngaro vms
*** TODO py : crashes on "help" - why?
*** TODO js : direct input for the terminal
*** TODO js : port 2 : sending negative value should clear the screen, but doesn't, in js version
#+begin_src javascript
portHandlers[2] = function()
{
  Term.renderChar( data.pop );
  ports[ 2 ] = 0;
}
#+end_src

** TODO discrepencies
port 5, -16 ( extended console? ) uses -1 to mean true... whereas elsewhere, it's just 1

* -- ancient wishlist ---
** NOTE on contributing to this project
*** these are things that are off the critical path (for now)
*** ~[#A]~ is easy, ~[#B]~ medium, ~[#C]~ advanced
*** i could use help with the [[file:b4.00.tasklist.org][main tasklist]], too, but:
***** usually discover i need something out of order
***** probably best to chat on freenode/#b4 if you want to work on main tasklist
*** licensing issues
- if you contribute / port something, make sure license is MIT/ [[http://en.wikipedia.org/wiki/ISC_license][ISC]] compatible ([[http://retroforth.org/license.html][retroforth license]] is ISC)
- [[http://www.freepascal.org/faq.var#general-license][freepascal]] code has a tendency to use MPL/LGPL style. I'm okay with that, too.

** WANT assembler
*** TODO make something similar to  [[https://github.com/oriontransfer/PL0-Language-Tools/blob/master/pl0_assemblera.py][pl/0 language tools assembler.py]]
*** DONE what is license on pl0 tools? -> relicensed under MIT when I asked
*** TODO compare bytecodes for pl/0 machine and ngaro. see what we need to adjust.
Both are stack machines and the primitives look similar.
See also python -> ngaro translator below.
Combined with PL/0 tools, these would give us all the tools we need.
*** NOTE I made a start on a completely different assembler in go/c4.py
*** NOTE pretty sure retroforth has an assembler - see file:ref/crc-retro-wisdom.org

** WANT relational database (b4 has tiny relational database)
*** [#C] [[http://en.wikipedia.org/wiki/B-tree][b-tree]] or [[http://en.wikipedia.org/wiki/B%2B_tree][b+-tree]] implementation                     :nga:
*** [#A] codd's 8 relational operators                        :nga:

There is psuedocode for all 8 here:

http://science.kennesaw.edu/~mguimara/3310/RA_SQL.htm

** WANT [#B] repl - probably follow itsyforth model
*** DONE track down itsyforth license  ( it's MIT-style )
**** ask the author (john metcalf)
**** [[http://www.retroprogramming.com/2012/03/itsy-forth-1k-tiny-compiler.html][itsyforth interpreter]]

** WANT port of gamesketchlib to ngaro/retroforth/b4

I made the java/processing game library at http://gamesketchlib.org/ and will try to follow the same design patterns as I work on this system.

** WANT python bytecode -> ngaro translator
*** [#A] research step : match up the two sets of bytecode

ngaro only has 30 instructions, python has around the same. There is much overlap, and in forth-like languages, it's very easy to translate things like this.

So it's possible that at least some python code should be able to run here. 

The first step would be to compile a table that compares and contrasts the two sets of bytecode:

[[http://docs.python.org/library/dis.html][python dis module]] and the opcode section in [[http://retroforth.org/docs/The_Ngaro_Virtual_Machine.html][ngaro-vm reference]]

*** ?? pending above step, add new primitives to let us run python

probably the most dynamic aspects of python will not run well, but simpler python code probably can. 

** WANT modfile player.

I would really really like a modfile player for retro sounds and music. (don't know what modfiles are? see http://modarchive.org/ )

#+begin_quote me

[13:04] <dom96> I always wanted to compete in Ludum Dare. Sadly, nowadays there isn't enough time.
[13:05] <tangentstorm> http://web.archive.org/web/20080704164939/http://turcanator.tangentcode.com/
[13:05] <tangentstorm> this is a midi sequencer i wrote in pygame... i would love it if someone took that and turned it into the music engine for this system.
[13:06] <tangentstorm> not the graphics part... but the time/synchronization code for the music events
[13:07] <tangentstorm> to make something like this: http://www.photonstorm.com/flod

#+end_quote

** WANT emacs mode for colorforth-like languages

B4 is a a colorized language: you syntax-highlight it yourself, to simplify the parser, and words change meaning (verb tense) based on color.

This looks promising:

http://www.strangegizmo.com/forth/ColorForth/msg00263.html

I have already written a partial retroforth mode in file://etc/retro-mode.el

** WANT render org-files to something more readable.           :elisp:
*** github makes org-code ugly
*** [#A] org itself does better job... make me a macro?
**** http://orgmode.org/
**** http://orgmode.org/worg/org-contrib/babel/ 
** WANT standalone org-babel-tangle (preferably in pascal)
** IDEA interface IDebuggable ?
It would probably have like a .tostring, plus menu options?

Not really sure what would be included in the interface, but I had the debugger in one section of my org-file for ngaro.pas.org, and then it got spread out.

** IDEA ramdisk / image layout
*** things that need to be in ram somewhere early:
**** the first 256 cells are reserved for registers
**** they also leave room for 256 ngaro-style opcodes
***** (these may be device-specific opcodes, too)
**** first eight bytes should be magic # : utf-16 for the four corners
***** TODO lookup the code points
***** the bios needs to fit in the next 512 bytes
**** map disk pages to ram (probably 4k blocks)
***** maybe give blocks a negative number to indicate system/hardware?
***** this makes sense, as we may have multiple machines in one image
***** btree for where things are laid out in memory
**** maybe a version number / hash for the interpreter config?
**** primary console video ram
**** the basic 256-character font (codepoints + 16 bytes)
**** the registers / stack for each machine
*** paging system
**** ngaro wants ram to be laid out in a specific way
**** the paging system would emulate contiguous ram
**** basically just like the processor does

** WANT clarify interfaces between the modules
#+DATE: [2012-09-20 Thu]
*** module io : high level input/output abstraction
**** module io_nw - network
**** module iokb - keyboard
**** module iohd - hard drive
**** module ioss - sound system
**** module iovm - interface to the vm itself
**** module ioip - interprocess communication
*** module vm : the virtual machine
*** module vt : virtual terminal
*** module ui : text widgets
*** module sg : scenegraph
* -- b4th --
** TODO [1/6] b4th : a bootstrapped forth-like environment
:PROPERTIES:
:TS: <2013-02-26 10:49AM>
:ID: cp73or9181g0
:END:
*** TODO license and header
:PROPERTIES:
:TS: <2013-02-26 10:51AM>
:ID: l01epu9181g0
:END:
#+begin_src b4th
# b4th : a bootstrapped forth-like environment
# --------------------------------------------------------------
# <<isc-license>>
# --------------------------------------------------------------
#+end_src

*** DONE layout of the image
:PROPERTIES:
:TS: <2013-02-25 10:10PM>
:ID: ihahkx7181g0
:END:
#+begin_src b4a :tangle "~/b/b4a/b4th.b4a" :padline yes :noweb tangle
<<b4:header>
JMP: --begin-- # jump over the data block
<<data>>
<<bios>>
:--begin--
<<boot>>
<<main>>
#+end_src

*** TODO SECT data - the data block
:PROPERTIES:
:TS: <2013-02-26 10:17AM>
:ID: zt36m98181g0
:END:
**** DONE Overview of the data block.
:PROPERTIES:
:TS: <2013-02-26 10:44AM>
:ID: 0ys5ji9181g0
:END:

#+name: @data
#+begin_src b4a
# -- DATA ------------------------------------------------------
<<data:end>
#+end_src

We will use the first 256-cell block (1KB) to hold global variables and system buffers.

Since the VM treats any number that is not an opcode as a call to a routine, this means the first 256 numbers can be used as opcodes. The default implementation requires only 30 opcodes, which leaves users plenty of room to add new opcodes if they want to experiment.

**** TODO End data block.
:PROPERTIES:
:TS: <2013-02-26 10:44AM>
:ID: dzshri9181g0
:END:

Now, tell the assembler to pad the rest of the 256-cell block with zeros.

#+name: data:end
#+begin_src b4a
 # <- http://en.wikipedia.org/wiki/End_Transmission_Block_character
#+end_src

*** TODO SECT bios - basic input/output system
:PROPERTIES:
:TS: <2013-02-26 10:37AM>
:ID: am5dc69181g0
:END:
#+name: bios
#+begin_src b4a
# -- BIOS ------------------------------------------------------
:bios
#+end_src

*** TODO SECT boot - the boot process
:PROPERTIES:
:TS: <2013-02-26 10:18AM>
:ID: 4v4j6b8181g0
:END:
#+name: boot
#+begin_src b4a
# -- BOOT --( boot process )------------------------------------
#+end_src

*** TODO SECT main - main loop
:PROPERTIES:
:TS: <2013-02-26 10:36AM>
:ID: wqoew49181g0
:END:
#name: main
#+begin_src b4a
# -- MAIN --( the main loop of the system )---------------------
:mainloop
JMP: mainloop
#+end_src

** TODO describe the stack machine's algorithm
:PROPERTIES:
:TS: <2013-02-16 06:58AM>
:ID: 4v58esp0v0g0
:END:
*** TODO simple flowchart
:PROPERTIES:
:TS: <2013-02-16 07:00AM>
:ID: yeg1ivp0v0g0
:END:
*** TODO capture this with "ifso/else" syntax
:PROPERTIES:
:TS: <2013-02-16 07:00AM>
:ID: l8z7nvp0v0g0
:END:
** NOTE . create an assembler via stepwise refinement
:PROPERTIES:
:TS: <2013-02-16 07:21AM>
:ID: hikafuq0v0g0
:END:
*** TODO write an assembler in pascal-like psuedocode
:PROPERTIES:
:TS: <2013-02-16 07:20AM>
:ID: mcgidsq0v0g0
:END:
*** TODO show how to translate that psuedocode to instructions
:PROPERTIES:
:TS: <2013-02-16 07:20AM>
:ID: qcue5tq0v0g0
:END:
** NOTE . block usage policy
:PROPERTIES:
:TS: <2013-02-16 06:20AM>
:ID: w13c71o0v0g0
:END:
I'm thinking for now, I would follow the colorforth convention of putting documentation in the odd numbered blocks and source code in the even numbered blocks. Some blocks would also be binary blocks used by the kernel.

In fact, I could just stipulate that up front: the first 16KB are reserved for the system, input buffer, memory map, etc... So code would start at $10.

** NOTE . block map
:PROPERTIES:
:TS: <2013-02-16 06:22AM>
:ID: 1pdg34o0v0g0
:END:
*** NOTE . core variables
:PROPERTIES:
:TS: <2013-02-16 06:30AM>
:ID: lvifqgo0v0g0
:END:
*** NOTE . core listener
:PROPERTIES:
:TS: <2013-02-16 06:29AM>
:ID: 8g36sfo0v0g0
:END:
*** NOTE . hex assembler
:PROPERTIES:
:TS: <2013-02-16 06:29AM>
:ID: ynhkffo0v0g0
:END:
*** NOTE . bootstrap system
:PROPERTIES:
:TS: <2013-02-16 06:30AM>
:ID: p1uk8go0v0g0
:END:
*** NOTE . core compiler
:PROPERTIES:
:TS: <2013-02-16 06:31AM>
:ID: 6c85sio0v0g0
:END:
**** def , (comma)
:PROPERTIES:
:TS: <2013-02-16 06:32AM>
:ID: po41oko0v0g0
:END:
*** NOTE . dictionary routines
:PROPERTIES:
:TS: <2013-02-16 06:34AM>
:ID: yq3ifno0v0g0
:END:
**** TODO find a word in the dictionary
:PROPERTIES:
:TS: <2013-02-16 06:35AM>
:ID: 6aq4qoo0v0g0
:END:
**** TODO simple hash function
:PROPERTIES:
:TS: <2013-02-16 06:35AM>
:ID: bjuexoo0v0g0
:END:

** TODO build a forth
:PROPERTIES:
:TS: <2013-02-01 06:08AM>
:ID: jfm9ysy0b0g0
:END:
*** TODO identify the branch/jump opcodes
:PROPERTIES:
:TS: <2013-02-01 06:11AM>
:ID: nvn67yy0b0g0
:END:
*** TODO start with an infinite loop
:PROPERTIES:
:TS: <2013-02-01 06:11AM>
:ID: j4s11zy0b0g0
:END:
*** TODO break the loop
:PROPERTIES:
:TS: <2013-02-01 06:12AM>
:ID: 1yr1dzy0b0g0
:END:
**** break on any key
:PROPERTIES:
:TS: <2013-02-01 06:18AM>
:ID: m1q4c9z0b0g0
:END:
Not really a loop at all, unless asking for a key blocks the cpu.
An async version might check a specific port for a signal.
**** read the key
:PROPERTIES:
:TS: <2013-02-01 06:16AM>
:ID: awbgp6z0b0g0
:END:
**** emit corresponding character to the screen
:PROPERTIES:
:TS: <2013-02-01 06:22AM>
:ID: mhk4sfz0b0g0
:END:
**** wait for specific key (C-c ? Esc ?)
:PROPERTIES:
:TS: <2013-02-01 06:16AM>
:ID: el4ie6z0b0g0
:END:

*** TODO accept a word
:PROPERTIES:
:TS: <2013-02-01 06:12AM>
:ID: gh80d0z0b0g0
:END:
**** create a buffer
:PROPERTIES:
:TS: <2013-02-01 06:23AM>
:ID: 6b7ehhz0b0g0
:END:

**** pack the string
:PROPERTIES:
:TS: <2013-02-01 06:15AM>
:ID: jc6hl5z0b0g0
:END:

*** TODO lookup word in dictionary
:PROPERTIES:
:TS: <2013-02-01 06:13AM>
:ID: atdl01z0b0g0
:END:
**** traverse the chain
:PROPERTIES:
:TS: <2013-02-01 06:14AM>
:ID: erccx3z0b0g0
:END:
**** compare to ram
:PROPERTIES:
:TS: <2013-02-01 06:15AM>
:ID: 107hd4z0b0g0
:END:

*** TODO obtain the code and type fields
:PROPERTIES:
:TS: <2013-02-01 06:13AM>
:ID: f8scq1z0b0g0
:END:
*** TODO execute the code
:PROPERTIES:
:TS: <2013-02-01 06:14AM>
:ID: i18jk3z0b0g0
:END:

** --- unfiled ---
:PROPERTIES:
:TS: <2013-02-26 08:23PM>
:ID: 0623cql091g0
:END:
*** JUNK bootstrap plan
PROPERTIES:
:TS: <2013-02-16 08:50AM>
:ID: ndpdhyu0v0g0
:END:

boot $okmsg $^heap

( compiler macros )
.r { .h      } ( repeat )
.u { .jump,, } ( until )


| boot    |   |   | ( put boot code here )          | falls through to main |
| main    | ? | ? | DRP prompt find process main    | tail call recursion   |
| prompt  |   | $ | NOP NOP $okmsg wr:s RET         | revectorable          |
| wr:s    | $ |   | NOP NOP .r DUP 0 EQ .u DRP RET  |                       |
| accept  | n | $ | NOP NOP 32 accept               |                       |
| find    |   |   |                                 |                       |
| process | ? | ? |                                 |                       |

*** IDEA create a simple game in pascal. translate to assembly. (mastermind?)
:PROPERTIES:
:TS: <2013-02-16 07:23AM>
:ID: e6v3wwq0v0g0
:END:
*** APPENDIX required word set from 1983
**** Nucleus layer

!  *  */  */MOD  +  +!  -  /  /MOD  0<  0=  0>  1+  1-  2+
2-  2/  <  =  >  >R  ?DUP  @  ABS  AND  C!  C@  CMOVE
CMOVE>  COUNT  D+  D<  DEPTH  DNEGATE  DROP  DUP  EXECUTE
EXIT  FILL  I  J  MAX  MIN  MOD  NEGATE  NOT  OR  OVER  PICK
R>  R@  ROLL  ROT  SWAP  U<  UM*  UM/MOD  XOR

**** Device layer

BLOCK  BUFFER  CR  EMIT  EXPECT  FLUSH  KEY  SAVE-BUFFERS
SPACE  SPACES  TYPE  UPDATE

**** Interpreter layer

#  #>  #S  #TIB  '  (  -TRAILING  .  .(  <#  >BODY  >IN
ABORT  BASE  BLK  CONVERT  DECIMAL  DEFINITIONS  FIND
FORGET  FORTH  FORTH-83  HERE  HOLD  LOAD  PAD  QUIT  SIGN
SPAN  TIB  U.  WORD

**** Compiler layer

+LOOP  ,  ."  :  ;  ABORT"  ALLOT  BEGIN  COMPILE  CONSTANT
CREATE  DO  DOES>  ELSE  IF  IMMEDIATE  LEAVE  LITERAL  LOOP
REPEAT  STATE  THEN  UNTIL  VARIABLE  VOCABULARY  WHILE  [
[']  [COMPILE]  ]

