[ 0 |                              # jump over bios
#--- begin bios -------------------\
:here 3 rt                         # names for some important registers
:last 4 rt
:ap   5 rt

:inc  1 ad rt

:a+ ap rm du dr wm                 # a+ ( n - ) , writes a value to the
    rd inc ap wm rt                #    address in ap and increments ap.

:, here rm du dr wm
    rd inc here wm rt              # , is exact same thing for the heap

:buf                               # allocate 80 characters for input
  02 04 06 08 10 12 14 16 18 20    # each one is 2 bytes because there's
  22 24 26 28 30 32 34 36 38 40    # a 'lit' opcode in front of each one.
  42 44 46 48 50 52 54 56 58 60
  62 64 66 68 70 72 74 76 78 80

:nl 10 putc 13 putc rt             # emit CRLF

:init $buf ap wm rt                # set ap = buf

:word rt                           # word handler (does nothing so far)

:exit nl 01 attr                   # red
  'e putc 'n putc 'd putc nl       # echo 'end'
  hl

:prompt
  nl 02 attr                       # green on black
  'o putc 'k putc '> putc          # echo 'ok>'
  02 attr 32 putc 07 attr rt       # gray on black for user input.


:eol =1                            # end of line flag

:repl { 1 |
  [ $eol rm | 0 $eol wm prompt ]   # show prompt if new line
  getc
  [ du 13 eq | zp 1 $eol wm word ] # on cr, set newline and run word
  [ du 04 eq | zp exit ]           # on ^d, exit
  [ du 31 ge | zp ]                # ignore other control chars
  du a+ putc } ]                   # others go to buffer with echo
#--- end of bios ------------------/

# -- main --
# 15 { dec du du | du attr '@ putc } # draw colors
# :once =1 [ $once rm | 0 $once wm init repl ]  # why doesn't this work?
init repl
