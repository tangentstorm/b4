[ si 00 |                          # jump over bios
#--- begin bios -------------------\
# names for some important registers
:here^ 00000000 04 'h 'e 'r 'e
:here  si 03 rt

:last^ $here^ 04 'l 'a 's 't
:last  si 04 rt

:ap   si 05 rt

:inc^ $last^ 03 'i 'n 'c
:inc  si 01 ad rt

:dec^ $inc^ 03 'd 'e 'c
:dec  si 01 sb rt

:a+ ap rm du dr wm                 # a+ ( n - ) , writes a value to the
    rd inc ap wm rt                #    address in ap and increments ap.

:,^ $dec^ 01 ',
:, here rm du dr wm
    rd inc here wm rt              # , is exact same thing for the heap

:buf-len 00                        # length of the buffer
:buf                               # 64-character input buffer
  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

:sp si 32 tw rt                    # emit space
:nl si 10 tw si 13 tw rt           # emit CRLF

:bye^ $,^ 03 'b 'y 'e
:exit nl si 01 ta                  # red
  si 'e tw si 'n tw si 'd tw       # echo 'end'
  nl hl

:b4>
  nl si 02 ta                      # green on black
  si 'b tw si '4 tw si '> tw       # echo 'b4>'
  si 32 tw si 07 ta                # gray on black for user input.
  rt

:puts^ $bye^ 04 'p 'u 't 's
:puts                              # given address of counted string, write the string
  du rm dr inc                     # push str start to d, len to r (loop counter)
  :for
    du rm tw
    inc
  nx $for
  zp rt

:words^ $puts^ 05 'w 'o 'r 'd 's
:words                             # list known words, starting at last entry:
  last rm
  { du si 0 ne |                   # we are looking at a non-0 pointer to entry
    du si 1 ad
    puts sp                        # emit str
    rm }                           # move to next entry
  zp rt


:dyn-call cl :dyn-adr 00 rt
:exec^ $words^ 04 'e 'x 'e 'c
:exec
  li $dyn-adr wm
  dyn-call
  rt

:e-nm^ $exec^ 04 'e '- 'n 'm
:e-nm si 1 ad rt                   # (e-s) address of string for enttry
:e-xt e-nm du rm ad rt             # (e-a) address of code for entry "execution token"

:s-eq^ $e-nm^ 04 's '- 'e 'q
:s-eq?                             # (st-?) are strings s and t the same?
  [ ov ov eq | eq rt ]             # a. if the addresses are the same, return 1
  [ ov rm du dr ov rm ne |         # b. (st-st?|n) if the lengths are different,
    rd zp eq rt ]                  #   drop loop counter and return 0 (we know eq=0 from a.)
  :for-s-eq                        # st|n   -> ready for a for -loop
    inc sw inc                     # st-TS  -> next char (doesn't matter that we swap order)
    [ ov rm ov rm ne |                   # if the characters are not equal
      rd zp eq rt ]                #   drop counter and return 0 (same as in b. before)
  nx $for-s-eq
  zp zp si 1 rt                    # everything matched, so return 1

:word?^ $s-eq^ 05 'w 'o 'r 'd '?
:word?                             # (s-e)   attempt to find word in dictionary
  dr                               # s - |s  push s to return stack
  last rm                          # ..-e|s  fetch last entry
  { du si 0 ne |                   # while e!=0 do:
    du e-nm                        #  ..- et|s     fetch the entry's name (t)
    rd du dr                       #  ..- ets|s
    [ s-eq? | rd zp rt ]           # return e if strings match
    rm }                           # otherwise, visit next string
  rd zp rt                         # (e|s - e)

   # instead of 'rd du dr'
   # :ru rd rd sw dr du dr rt           # (-s) copy top of R to D
   # !! might be nice to have macros for inlining this


# :words-s li $words^ si 1 ad rt   # (-s) address of the string "words"
:words-s li $words^ e-nm rt        # (-s) address of the string "words"
:word?-s li $word? e-nm rt        # (-s) address of the string "word?"

:init
  li $buf ap wm                    # set ap = buf
  li $word?^ last  wm
  rt

:unkno-s 13 'u 'n 'k 'n 'o 'w 'n 32 'w 'o 'r 'd '.
:unknown
 si 08 ta sp li $unkno-s puts nl rt
 # word?-s puts nl rt

:eol 01                            # end of line flag
:repl { si 01 |
  [ li $eol rm |                   # if end of line flag
    si 00 li $eol wm b4> ]         # show prompt if new line
  tr                               # read char from terminal
  [ du si '` eq | db ]             # ` = debugger
  [ du si 32 eq | tw si 0          # on space,  (echo space and add dummy char)
    si 01 li $eol wm               #    set the eol flag
    ap rm li $buf sb               #    calculate length: start of buffer
    li $buf-len sw ov wm           #    save the lenegth
    li $buf ap wm                  #    reset ap to start of buffer
    word?                          #    look up the word
    [ du si 0 eq | zp unknown ]    #    if not found, complain
    [ du si 0 ne | exec ] ]        #    if found, execute   (# TODO: 'else' !!)
  [ du si 31 lt | du du a+ tw ]    # copy non-ctrl chars to buffer and echo
  [ du si 04 eq | exit ]           # on ^d, exit
  zp }                             # drop the character

# this should never execute, so trigger debugger if we get here:
db ]
#--- end of bios ------------------/

# -- debug /test stuff --
# [ si 0 | :word-a 03 'a 'b 'c :word-b 03 'a 'b 'c ]
# li $word-a li $word-b s-eq?
# word?-s words-s s-eq? db   (s-eq working)
# words-s word? db           ( word? seems to be working)
# si 16 { dec du | du ta si '. tw } zp nl # draw colors

# -- main --
init
# show the word list:
si 14 ta words-s puts si ': tw sp si 07 ta words nl
repl
