[ si 00 |                          # jump over bios
#--- begin bios -------------------\
:here si 03 rt                     # names for some important registers
:last si 04 rt
:ap   si 05 rt
:dbg  si 01 si 07 wm rt            # turn debugger on

:inc  si 01 ad rt
:dec  si 01 sb rt

:a+ ap rm du dr wm                 # a+ ( n - ) , writes a value to the
    rd inc ap wm rt                #    address in ap and increments ap.

:, here rm du dr wm
    rd inc here wm rt              # , is exact same thing for the heap

:buf                               # allocate 80 characters for input
  02 04 06 08 10 12 14 16 18 20    # each one is 2 bytes because there's
  22 24 26 28 30 32 34 36 38 40    # a 'lit' opcode in front of each one.
  42 44 46 48 50 52 54 56 58 60
  62 64 66 68 70 72 74 76 78 80

:nl si 10 putc si 13 putc rt       # emit CRLF

:init $buf ap wm rt                # set ap = buf

:word rt                           # word handler (does nothing so far)

:exit nl si 01 attr                # red
  si 'e putc si 'n putc si 'd putc # echo 'end'
  nl hl

:b4>
  nl si 02 attr                    # green on black
  si 'b putc si '4 putc si '> putc # echo 'b4>'
  si 02 attr si 32 putc si 07 attr # gray on black for user input.
  rt rt

:eol 01                            # end of line flag

:repl { si 01 |
  [ $eol rm | si 00 $eol wm b4> ]  # show prompt if new line
  getc
  [ du si 13 eq |                  # on enter,
    si 01 $eol wm word ]           # execute word (does nothing yet)
  [ du si 04 eq | exit ]           # on ^d, exit
  [ du si 31 lt | du a+ putc ] }   # copy non-ctrl chars to buffer and echo

# this should be compiled, but never execute:
hl ]
#--- end of bios ------------------/

# -- main --
si 15 { dec du | du attr si '. putc } zp # draw colors
init repl
