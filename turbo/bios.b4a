[ 0                                # jump over bios
| #--- begin bios -----------------#
:@  get ret                        # these are forth syntax for get/put
:!  set ret
:. drop ret

:here 3 ret                        # names for some important registers
:last 4 ret
:ap   5 ret

:a+ ap @ dup push !                # a+ ( n - ) , writes a value to the
    pop inc ap ! ret               #    address in ap and increments ap.

:, here @ dup push !
    pop inc here ! ret             # , is exact same thing for the heap

:buf                               # allocate 80 characters for input
  02 04 06 08 10 12 14 16 18 20    # each one is 2 bytes because there's
  22 24 26 28 30 32 34 36 38 40    # a 'lit' opcode in front of each one.
  42 44 46 48 50 52 54 56 58 60
  62 64 66 68 70 72 74 76 78 80

:nl 10 putc 13 putc ret            # emit CRLF

:init $buf ap ! ret                # set ap = buf

:word ret                          # word handler (does nothing so far)

:exit nl 01 attr                   # red
  101 putc 110 putc 100 putc nl    # echo 'end'
  halt

:ok
  nl 02 attr                       # green on black
  111 putc 107 putc 62 putc        # echo 'ok>'
  02 attr 32 putc 07 attr ret      # gray on black for user input.


:eol =1                            # end of line flag

:repl { 1 |
  [ $eol @ | 0 $eol ! ok ]         # show prompt if new line
  getc
  [ dup 13 eq | . 1 $eol ! word ]  # on cr, set newline and run word
  [ dup 04 eq | . exit ]           # on ^d, exit
  [ dup 31 ge | . ]                # ignore other control chars
  dup a+ putc }                    # others go to buffer with echo
] #--- end of bios ----------------#

# -- main --
# 15 { dec dup dup | dup attr 64 putc } # draw colors
# :once =1 [ $once @ | 0 $once ! init repl ]  # why doesn't this work?
init repl