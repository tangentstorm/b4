!i lb 00 !t                        # jump over bios
#--- begin bios -------------------\
# names for some important registers
:here^ 00 00 00 00 04 'h 'e 'r 'e
:here  lb 12 rt

:last^ $here^ 04 'l 'a 's 't
:last  lb 16 rt

:ap   lb 20 rt

:inc^ $last^ 03 'i 'n 'c
:inc  lb 01 ad rt

:dec^ $inc^ 03 'd 'e 'c
:dec  lb 01 sb rt

:a+ ap ri du dr wb                 # a+ ( n - ) , writes a value to the
    rd inc ap wi rt                #    address in ap and increments ap.

:,^ $dec^ 01 ',
:, here ri du dr wb
    rd inc here wi rt              # , is exact same thing for the heap

:tok-len 00                        # length of the current token
:tok                               # 64-byte token buffer
  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

:sp lb 32 tw rt                    # emit space
:nl lb 10 tw lb 13 tw rt           # emit CRLF

:bye^ $,^ 03 'b 'y 'e
:exit nl lb 01 ta                  # red
  lb 'e tw lb 'n tw lb 'd tw       # echo 'end'
  nl hl

:b4>
  nl lb 02 ta                      # green on black
  lb 'b tw lb '4 tw lb '> tw       # echo 'b4>'
  lb 32 tw lb 07 ta                # gray on black for user input.
  rt

:puts^ $bye^ 04 'p 'u 't 's
:puts                              # given address of counted string, write the string
  du rb dr inc                     # push str start to d, len to r (loop counter)
  :for
    du rb tw
    inc
  nx $for
  zp rt

:e-nm^ $puts^ 04 'e '- 'n 'm
:e-nm lb 4 ad rt                   # (e-s) address of name relative to entry

:e-xt^ $e-nm^ 04 'e '- 'x 't
:e-xt e-nm du rb ad rt             # (e-a) address of code for entry "execution token"

:words^ $e-nm^ 05 'w 'o 'r 'd 's
:words                             # list known words, starting at last entry:
  last ri
  !w du lb 0 ne !d                 # we are looking at a non-0 pointer to entry
    du e-nm
    puts sp                        # emit str
    ri !o                          # move to next entry
  zp rt

:dyn-call cl :dyn-adr 00 00 00 00 rt
:exec^ $words^ 04 'e 'x 'e 'c
:exec
  e-xt
  li $dyn-adr wi
  dyn-call
  rt


:s-eq^ $exec^ 04 's '- 'e 'q
:s-eq?                             # (st-?) are strings s and t the same?
  !i ov ov eq !t eq rt !z          # a. if the addresses are the same, return 1
  !i ov rb du dr ov rb ne !t       # b. (st-st?!tn) if the lengths are different,
    rd zp eq rt !z                 #   drop loop counter and return 0 (we know eq=0 from a.)
  :for-s-eq                        # st!tn   -> ready for a for -loop
    inc sw inc                     # st-TS  -> next char (doesn't matter that we swap order)
    !i ov rb ov rb ne !t           # if the characters are not equal
      rd zp eq rt !z               #   drop counter and return 0 (same as in b. before)
  nx $for-s-eq
  zp zp lb 1 rt                    # everything matched, so return 1

:word?^ $s-eq^ 05 'w 'o 'r 'd '?
:word?                             # (s-e)   attempt to find word in dictionary
  dr                               # s - !ts  push s to return stack
  last ri                          # ..-e!ts  fetch last entry
  !w du lb 0 ne !d                 # while e!=0 do:
    du e-nm                        #  ..- et!ts     fetch the entry's name (t)
    rd du dr                       #  ..- ets!ts
    !i s-eq? !t rd zp rt !z        # return e if strings match
    ri !o                          # otherwise, visit next string
  rd zp rt                         # (e!ts - e)

   # instead of 'rd du dr'
   # :ru rd rd sw dr du dr rt           # (-s) copy top of R to D
   # !! might be nice to have macros for inlining this


# :words-s li $words^ lb 1 ad rt   # (-s) address of the string "words"
:words-s li $words^ e-nm rt        # (-s) address of the string "words"
:word?-s li $word? e-nm rt         # (-s) address of the string "word?"

:init
  li $tok ap wi                    # set ap = tok
  li $word?^ last  wi
  rt

:unkno-s 13 'u 'n 'k 'n 'o 'w 'n 32 'w 'o 'r 'd '.
:unknown
 lb 08 ta sp li $unkno-s puts nl rt

:eol 01                            # end of line flag
:repl !w lb 01 !d
  !i li $eol rb !t                 # if end of line flag
    lb 00 li $eol wb b4> !z        # show prompt if new line
  tr                               # read char from terminal
  !i du lb '` eq !t db !z          # ` = debugger
  !i du lb 32 eq !t tw lb 0        # on space,  (echo space and add dummy char)
    lb 01 li $eol wb               #    set the eol flag
    ap ri li $tok sb               #    calculate length: start of token buffer
    li $tok-len sw ov wb           #    save the length
    li $tok ap wi                  #    reset ap to start of buffer
    word?                          #    look up the word
    !i du lb 0 eq !t zp unknown !z #    if not found, complain
    !i du lb 0 ne !t exec !z !z    #    if found, execute   (# TODO: 'else' !!)
  !i du lb 31 lt !t du du a+ tw !z # copy non-ctrl chars to buffer and echo
  !i du lb 04 eq !t exit !z        # on ^d, exit
  zp !o                            # drop the character

# this should never execute, so trigger debugger if we get here:
db !z
#--- end of bios ------------------/

# -- debug /test stuff --
# !i lb 0 !t :word-a 03 'a 'b 'c :word-b 03 'a 'b 'c !z
# li $word-a li $word-b s-eq?
# word?-s words-s s-eq? db   (s-eq working)
# words-s word? db           ( word? seems to be working)
# lb 16 !w dec du !d du ta lb '. tw !z zp nl # draw colors

# -- main --
init
# show the word list:
lb 14 ta words-s puts lb ': tw sp lb 07 ta words nl
repl
