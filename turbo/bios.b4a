[ 0                                # jump over bios
| #--- begin bios -----------------#
:@ rm rt                           # these are forth syntax for get/put
:! wm rt
:. zp rt
:+ ad rt

:here 3 rt                         # names for some important registers
:last 4 rt
:ap   5 rt

:inc  1 ad rt

:a+ ap @ du dr !                   # a+ ( n - ) , writes a value to the
    rd inc ap ! rt                 #    address in ap and increments ap.

:, here @ du dr !
    rd inc here ! rt               # , is exact same thing for the heap

:buf                               # allocate 80 characters for input
  02 04 06 08 10 12 14 16 18 20    # each one is 2 bytes because there's
  22 24 26 28 30 32 34 36 38 40    # a 'lit' opcode in front of each one.
  42 44 46 48 50 52 54 56 58 60
  62 64 66 68 70 72 74 76 78 80

:nl 10 putc 13 putc rt             # emit CRLF

:init $buf ap ! rt                 # set ap = buf

:word rt                           # word handler (does nothing so far)

:exit nl 01 attr                   # red
  'e putc 'n putc 'd putc nl       # echo 'end'
  hl

:prompt
  nl 02 attr                       # green on black
  'o putc 'k putc '> putc          # echo 'ok>'
  02 attr 32 putc 07 attr rt       # gray on black for user input.


:eol =1                            # end of line flag

:repl { 1 |
  [ $eol @ | 0 $eol ! prompt ]     # show prompt if new line
  getc
  [ du 13 eq | . 1 $eol ! word ]   # on cr, set newline and run word
  [ du 04 eq | . exit ]            # on ^d, exit
  [ du 31 ge | . ]                 # ignore other control chars
  du a+ putc }                     # others go to buffer with echo
] #--- end of bios ----------------#

# -- main --
# 15 { dec du du | du attr '@ putc } # draw colors
# :once =1 [ $once @ | 0 $once ! init repl ]  # why doesn't this work?
init repl
