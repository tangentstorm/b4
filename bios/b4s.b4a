# b4s : symbolic processing

# allocate some space for cells
# note this is probably far ahead in memory and there is nothing
# to prevent the assembler from writing over it.

# TODO: the assembler needs :|8 to allign and :+<size> to allocate

:fst^ 00 10 .. ..                       # ptr to first normal cell
:end^ 00 30 .. ..                       # ptr to end of cell memory
:nil^ .. .. .. ..                       # address of nil
:nxt^ .. .. .. ..                       # ptr to next free cell (init=same as fst^)
:numc .. .. .. ..                       # total number of cells. 'inic' makes this

:car  ri rt     :cdr  c4 ad ri rt       # get car, cdr
:car! wi rt     :cdr! c4 ad wi rt       # set car, cdr
:nil @nil^ rt   :nil? @nil^ eq rt       # push / test nil

:inic                                   # init cells (by making a linked list)
   @end^ @fst^ sb lb 08 dv c1 sb !numc  # numc := number of cells (leave 1 at end for nil)
   @fst^ !nxt^                          # point nxt^ at first free cell
   @end^ lb 08 sb !nil^                 # nil^ := last cell
   @nil^ du du du car! cdr!             # nil := (nil . nil)
   @A dc @fst^ !A                       # A := first cell
   @numc .f                             # for each real cell (non-nil)
      lb 08 +A @A sw wi .n              # link it to the next cell (last -> nil)
   cd !A rt

:celn du nil?                           # (c-n) cell number (for testing without fixed addrs)
   .i zp n1                             # nil = -1
   .e @fst^ sb lb 8 dv .t rt            # otherwise find offset and div by 8

:nxtc @nxt^ du ri !nxt^ rt              # (-c) claim next free cell

 # - cnum : wrap a number
 # - cnum
 # - csym
 # - cons



 # # printer

 # - numbers
 # - symbols
 # - lists

# constructors