# b4s : symbolic processing

# allocate some space for cells
# note this is probably far ahead in memory and there is nothing
# to prevent the assembler from writing over it.

# TODO: the assembler needs :|8 to allign and :+<size> to allocate

:fst^ 00 C0 .. ..   :end^ 00 E0 .. ..   # addrs: start & just past end of cells
:nil^ .. .. .. ..   :nxt^ .. .. .. ..   # addrs: nil and next free cell
:numc .. .. .. ..                       # total number of cells. 'inic' makes this

:ctyp lb 06 an rt                       # ctyp: (c-t) return the cell's type code
:wipe lb 06 nt an rt                    # wipe: (c-c) remove type code
:ntag wipe c2 xr rt                     # ntag: tag cell as number
:stag wipe c4 xr rt                     # ntag: tag cell as symbol

:car  wipe ri rt :cdr  wipe c4 ad ri rt # get car, cdr (c - c)
:car! wipe wi rt :cdr! wipe c4 ad wi rt # set car, cdr (x c -)
:nil @nil^ rt    :nil? @nil^ eq rt      # push / test nil

:inic                                   # init cells (by making a linked list)
   @end^ @fst^ sb lb 08 dv c1 sb !numc  # numc := number of cells (leave 1 at end for nil)
   @fst^ !nxt^                          # point nxt^ at first free cell
   @end^ lb 08 sb !nil^                 # nil^ := last cell
   @nil^ du du du car! cdr!             # nil := (nil . nil)
   @A dc @fst^ !A                       # A := first cell
   @numc .f                             # for each real cell (non-nil)
      lb 08 +A @A sw wi .n              # link it to the next cell (last -> nil)
   cd !A rt

:celn du nil?                           # (c-n) cell number (for testing without fixed addrs)
   .i zp n1                             # nil = -1
   .e @fst^ sb lb 8 dv .t rt            # otherwise find offset and div by 8

:nxtc @nxt^ du ri !nxt^ rt              # (-c) claim next free cell
:cons nxtc sw ov cdr! sw ov car! rt     # (ad-c) construct cell with car:a cdr:d
:encl nil sw cons rt                    # encl: (-c) enclose a b4 value in a cell (nil . x)


# --- numbers --------------------------
:cnum encl ntag rt                      # cnum: (n-c) construct b4s number from raw b4 [n-nc-cn-cnc]
:pnum cdr putn rt                       # pnum: (c- ) print b4s number

# --- symbols --------------------------
:glu lb 03 .f lb 08 sh ad .n rt         # glu: (abcd-4) glue up to 4 chars together. ex: 'a 'b 'c 0 m4c
:o4c c4 .f                              # o4c: (4-) output a 4-char symbol. loop 4 times:
     du lb FF an du .i ^O .e zp .t      #   loop and print non-0 char
     ls -8 sh .n zp rt                  #   then shift over one char
:csym encl stag rt                      # csym: (4-c) construct symbol from 4-char
:psym cdr o4c rt                        # psym: (c- ) print symbol

# --- lists and values -----------------

:ptl du nil? .i zp rt                   # (c-) helper for plis. if nil, we're at the end, so stop.
  .e sp du ctyp                         # else emit space, then either '. x' or 'x'
     .i lb '. ^O sp cl >pval rt         # ctyp=="atom?" if so, dotted pair.
     .e du car cl >pval                 # else print the car and recurse on cdr
        cdr jm `ptl .t .t               # optimized tail call (no 'rt')

:plis                                   # (c-) print a list
  lb '( ^O
  du nil? nt .i
     du car cl >pval
     cdr ptl
  .t lb ') ^O rt

:pval du ctyp                           # (c-) print any cell
   du c4 eq .i zp psym rt .t
   du c2 eq .i zp pnum rt .t
   zp plis rt


#-- reader -----------------------------

:symw glu csym sw cons rt               # wrap with symbol
:wquo m! li 'q 'u 'o .. symw rt
:wdnq m! li 'u 'p 'q .. symw rt
:wupq m! li 'd 'n 'q .. symw rt

:do     dc rt
:mdo m! dc rt
:end m\ c0 ch eq !M rt
:any m\ end nt rt
:err m! m0 puts rt

#-- these read between @S and @L

:between?        # (xlh-?)
  dc ov dc lt nt                         # -?:xh  x
  cd cd lt                               # -?:xh    -??         -?
  an rt

:gte m! ch lt nt !M rt
:lte m! ch sw c1 ad lt !M rt
:ddgt m! lb '0 gte lb '9 lte lb
      m! @A lb 10 rt
:hdgt rt

:digit?                                 # (c-d1) or (c-0)
   du lb '0 lb ': between?
   .i lb '0 sb c1 rt .t
   du lb 'A lb 'G between?
   .i lb 'A sb lb 0A ad c1 rt .t
   zp c0 rt

:to-n @S dc
   !S c0 !R
   c1 +S rb .f
      c1 +S rb digit?
      .i @R li `base rb ml ad !R
      .e brkf .t
   .n
   cd !S @R rt                         # (pr-r)

:rnum m! @N cnum !R rt
:rsym m! rt

:rlis m! rt #@L dc nxcl !L

:ws m\ '  lte mf1 rt
:ws* li `ws orp rt

:rval k( lb '( chr rlis
      m| lb '' chr rval wquo
      m| lb '` chr rval wupq
      m| lb ', chr rval wdnq
      m| mhex ws* rnum          # leave cnum in !P
      m| li `any rep rsym
      m| .[ ."bad syntax" .]  err
      k) rt
