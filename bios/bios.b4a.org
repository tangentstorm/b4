#+title: the b4 bios

* scope of the bios

- define dictionary of programs and enable running a program by name
- provide a basic interactive shell for launching programs (when the system is running in standalone mode)

* structure

#+begin_src b4a :tangle bios.b4a :noweb yes

  # note: bios.b4a is generated from bios.b4a.org
  # I'm keeping it in version control until I have
  # a decent command-line build step for tangling
  # the org file, because the pascal code requires it.

  #--- begin bios -------------------\
  <<term-ops>>
  <<initial-words>>
  <<b4-repl>>
  <<string-table>>
  #--- end of bios ------------------/
  '- '- '- 'e 'n 'd '- 'o 'f '- 'b 'i 'o 's '- '- '-
  <<main>>
#+end_src

* =^X= : eXecute

The very first thing we want is an op to let us call a function dynamically.

There's a hidden "dynamic jump" operation, in the form of pushing
an address to the control stack and then invoking the "return" operation.

So we call that ^X for execute.

#+name: ^X
#+begin_src b4a
:X dc rt             # (f-?) execute f by pushing to ctrl stack and "returning"
#+end_src

* word lists
** =@^= holds the dictionary

Here the dictionary is a linked list. The pointer to the last entry is traditionally called "last" in forth. In b4, we still pronource it "last"
but it's actually stored in the =^^= ("carat") register, and we can just fetch its value directly with =@^=.

There is a corresponding assembler macro called =.^= which can assemble
a linked list for us as we go along.

** accessors

Entries in the dictionary are records with several fields:

| name      | size    | purpose                          |
|-----------+---------+----------------------------------|
| (no name) | 4 bytes | address previous entry           |
| e-nm      | varies  | counted string                   |
| e-xt      | varies  | start of the data/code for entry |


#+name: e-nm
#+begin_src b4a
:e-nm lb 04 ad rt                  # (e-s) address of name relative to entry
#+end_src

#+name: e-xt
#+begin_src b4a
:e-xt e-nm du rb lb 01 ad ad rt        # (e-a) address of code for entry "execution token"
#+end_src

** looking up a word with "find"

#+name: nz?
#+begin_src b4a
  :nz? lb 00 eq nt rt                 # (x-0|1) was x non-zero?
#+end_src

#+name: find
#+begin_src b4a
  :find                               # (s - 0|e) find s in dictionary
    @T dc !T @^                       # (s - e :-T)
    .w du nz? .d                      # (se - se?)  while e!=0 do:
       du e-nm @T ^Q                  # (see -sen) fetch name, test condition ^Q
          .i cd !T rt .t              #          return if matched
       ri .o                          # (e - e') otherwise, move on to next entry
    cd !T rt                          # (0) e=0 so return it as fail result
#+end_src

** string compare

#+name: s-eq?
#+begin_src b4a
  :s-eq? ^Q rt                        # (st-?) are strings s and t the same?

  :s-eq?-main                         # -- python translation:
     vb @S @T eq .i                   # if s is t:
        lb 01 rt .t                   #    return 1
     +S rv @T rv eq .i                # if len(s) == len(t):
        +T rv .f                      #    for s,t
           +S rv +T rv                #    in zip(s,t):
           eq nt .i                   #       if s!=t:
              lb 00 rt .t .n          #          return 0
     .e lb 00 rt .t                   # else: return 0
     lb 01 rt                         # return 1

  # !! This is experiment in style. I plan to make a nice syntax
  #    for this register capture/restore behavior.
  :Q @T dc !T                         # capture arg T
        @S dc !S                      # capture arg S
           s-eq?-main
        cd !S                         # restore S
     cd !T                            # restore T
     rt

#+end_src

** dynamic execution

Once we've found a dictionary entry to execute, we just
need to fetch its xt field and then call ^X.

#+name: exec
#+begin_src b4a
:exec e-xt dc rt
#+end_src

* TODO =^@= to build tokens

#+begin_src b4a

#+end_src

* TODO ^Y: yield (so we can do different things with the word list)

* list the words

The word =words= reads from =last= to find the end of the chain, then
walks the chain backwards, printing each name.

#+name: words
#+begin_src b4a
:words @^                          # list known words, starting at last entry.
  .w du nz? .d                     # while address != 0
     du e-nm puts sp               # print the word followed by a space
     ri .o                         # move to next entry
  zp rt                            # drop the final null pointer
#+end_src

* terminal device

These were previously opcodes in the pascal version, now consolidating into an individual "op":

#+name: term-ops
#+begin_src b4a
  :tg lb 'g tm rt # (xy-) goto xy
  :ta lb 'a tm rt # (a-) set terminal attribute ((fg << 4) + bg))
  :E :tw lb 'e tm rt # write (emit) char
  :tr lb 'r tm rt # readkey
  :tk lb 'k tm rt # keypressed?
  :ts lb 's tm rt # clear screen
  :tl lb 'l tm rt # clear line
  :tc lb 'p tm rt # (-xy) fetch cursor position
#+end_src

* main code

This is the part at the bottom of the file that actually executes.

The ~:\~ assigns the ~^\~ register to this address, indicating where the
emulator should set the initial instruction pointer.

At runtime, we need to initialize some variables:

#+name: main
#+begin_src b4a
    :\ # start of execution.
    # show word list and enter repl.
    lb 14 ta
    li `words$ e-nm puts lb ': tw sp lb 07 ta words nl
    repl
#+end_src

* text i/o

#+name: b4-io-words
#+begin_src b4a
  :sp lb 32 ^E rt                    # emit space
  :nl lb 10 ^E lb 13 ^E rt           # emit CRLF
#+end_src

#+name: puts
#+begin_src b4a
  :puts @S dc !S vb                  # given address of counted string s, write s
    +S rv .f +S rv ^E .n
    cd !S rt
#+end_src

#+name: putn/base
#+begin_src b4a
# reading/writing numbers

:base 10 :digit  '0'1'2'3'4'5'6'7'8'9'A'B'C'D'E'F
#+end_src

#+name: putn
#+begin_src b4a
  :putn # (n - )
    hx rt
    du lb 00 eq .i lb '0 tw rt
    .e lb 00 sw                      # ( n-kn) k:digit count=0
       .w du lb 00 eq nt .d          # while n!=0 do
          li `base rb dvm            # (kn-kdm) divmod
          li `digit ad rb dc         # (kdm-kd|c) push char to retn stack
          sw inc sw .o               # k++, d is new n
        zp                           # (kd-k)
        .f cd cd tw dc .n .t         # loop through the characters
    rt

#+end_src


#+name: try-num
#+begin_src b4a
:digit?                            # (c-d1) or (c-0)
 du lb '0 lb '9 between? .i
    zp lb '0 sb n1
 .e zp lb 0 .t
 rt

:try-num                           # (s-n) try to parse string as number
  du rb dc                         # (s    - s|i) a=addr of string
  lb 0                             # (s|i  - sr|i) r=0
  cd .f dc inc du rb               # (ar|i - ac|ri) a=addr of char, c=char
     digit? .i
        cd lb 10 ml ad dc          #  r= r*10+d
     .e unknown
        zp cd zp cd zp rt .t       # drop result and return
     cd                            # (p|ri - pr|i) so next can do its thing
  .n
  sw zp rt                         # (pr-r)

#+end_src

* the repl
** main logic
#+name: b4-repl
#+begin_src b4a

  :B 00 # length byte, plus 64-byte buffer
  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

  :eol 01                            # end of line flag
  :eol? li `eol rb rt
  :eol0 lb 00 li `eol wb rt
  :eol1 lb 01 li `eol wb rt

  :ctrl? lb 32 lt rt

  :on-space tw # (20 - )
     eol1
     @B find
     du nz?
        .i exec
        .e try-num .t
     rt

  :@ :on-ascii              # can't call ^@ directly. 00=no-op
     du tw vb +C wv
     @B rv inc @B wv
     rt

  :D bye       # exit on ^D
  :G db rt     # debug on ^G

  :on-key
     du lb 32 eq
        .i on-space rt
        .e du ctrl?
           .i lb 04 ml ri dc rt rt       # register dispatch for ctrl keys
           .e on-ascii rt .t .t
     rt

  :repl
     .w lb 01 .d
        eol?
        .i eol0 lb 00 @B wb @B inc !C b4> .t  # show prompt if new line
        tr on-key                     # read char from terminal
     .o
#+end_src

** the prompt
#+name: b4-prompt
#+begin_src b4a
:b4>
  nl lb 02 ta                      # green on black
  lb 'b tw lb '4 tw lb '> tw       # echo 'b4>'
  lb 32 tw lb 07 ta                # gray on black for user input.
 rt
#+end_src

** "bye" word
#+name: bye
#+begin_src b4a
:bye nl lb 01 ta                   # red
  lb 'e tw lb 'n tw lb 'd tw       # echo 'end'
  nl hl
#+end_src

** repl: unknown word
#+name: unknown
#+begin_src b4a
:unkno-s 13 'u'n'k'n'o'w'n' 'w'o'r'd'.
:unknown
 lb 08 ta sp li `unkno-s puts nl rt
#+end_src

* math library
** public words
#+name: inc
#+begin_src b4a
:inc  lb 01 ad rt
#+end_src

#+name: dec
#+begin_src b4a
:dec  lb 01 sb rt
#+end_src

** private words
#+name: b4-math
#+begin_src b4a

:dvm  # n d
  ov ov md      # (xy-xy|m)
  dc dv cd rt   # (xy|m-dm|)

:between?                          # (x hi lo - x f)
  du dc lt nt                      # (x <=hi? |lo)  (x<=y is -.(y>x))
  ov cd sw lt nt an rt             # (x f)

:n1 lb 00 nt rt                    # TODO: better way to write "-1"

#+end_src


* initial dictionary
#+name: initial-words
#+begin_src b4a :noweb yes :noweb-prefix no

  <<^X>>

  :ri vi rv rt  :rb vb rv rt
  :wi vi wv rt  :wb vb wv rt
  <<nz?>>

  .^ 04 'e'-'n'm
    <<e-nm>>
  .^ 04 'e'-'x't
    <<e-xt>>

  .^ 03 'i'n'c
    <<inc>>
  .^ 03 'd'e'c
    <<dec>>
  .^ 04 'f'i'n'd
    <<find>>
  .^ 04 's'-'e'q
    <<s-eq?>>
  .^ 04 'e'x'e'c
    <<exec>>

    <<b4-math>>
    <<b4-io-words>>
  .^ 03 'b'y'e
    <<bye>>
    <<b4-prompt>>
  .^ 04 'e'm'i't
    <<emit>>
  .^ 04 'p'u't's
    <<puts>>

  :words$ .^ 05 'w'o'r'd's
    <<words>>
    <<unknown>>
    <<putn/base>>
  .^ 04 'p'u't'n
    <<putn>>
    <<try-num>>
#+end_src
