#+title: the b4 bios

** scope of the bios

- define dictionary of programs and enable running a program by name
- provide a basic interactive shell for launching programs (when the system is running in standalone mode)

* structure

#+begin_src b4a :tangle bios.b4a :noweb yes

  # note: bios.b4a is generated from bios.b4a.org
  # I'm keeping it in version control until I have
  # a decent command-line build step for tangling
  # the org file, because the pascal code requires it.

  #--- begin bios -------------------\
  <<term-ops>>
  <<initial-words>>
  <<b4-repl>>
  <<string-table>>
  #--- end of bios ------------------/
  '- '- '- 'e 'n 'd '- 'o 'f '- 'b 'i 'o 's '- '- '-
  <<main>>
#+end_src


* terminal io

These were previously opcodes in the pascal version, now consolidating into an individual "op":

#+name: term-ops
#+begin_src b4a
  :tg lb 'g tm rt # (xy-) goto xy
  :ta lb 'a tm rt # (a-) set terminal attribute ((fg << 4) + bg))
  :tw lb 'e tm rt # write (emit) char
  :tr lb 'r tm rt # readkey
  :tk lb 'k tm rt # keypressed?
  :ts lb 's tm rt # clear screen
  :tl lb 'l tm rt # clear line
  :tc lb 'p tm rt # (-xy) fetch cursor position
#+end_src


* main code

This is the part at the bottom of the file that actually executes.

The ~:\~ assigns the ~^\~ register to this address, indicating where the
emulator should set the initial instruction pointer.

At runtime, we need to initialize some variables:

This is setting the variable =ap= to the start of the token buffer,
and then sets the =last= pointer to the last defined word in the
dictionary.

#+name: main
#+begin_src b4a
  :\ # start of execution.
  li `tok !S # initialize string pointer
  # show word list and enter repl.
  lb 14 ta words-s puts lb ': tw sp lb 07 ta words nl
  repl
#+end_src

* modules
* word lists

The system tracks the address of the last link in a variable called =last=.
The label here is to a function that puts its address onto the stack.

#+name: last
#+begin_src b4a
:last  @^ rt
#+end_src

** accessors

Entries in the dictionary form a linked list of records.

The records have several fields:

| name      | size    | purpose                          |
|-----------+---------+----------------------------------|
| (no name) | 4 bytes | link to previous entry           |
| e-nm      | varies  | counted string                   |
| e-xt      | varies  | start of the data/code for entry |


#+name: e-nm
#+begin_src b4a
:e-nm lb 4 ad rt                   # (e-s) address of name relative to entry
#+end_src

#+name: e-xt
#+begin_src b4a
:e-xt e-nm du rb ad rt             # (e-a) address of code for entry "execution token"
#+end_src

** list the words

The word =words= reads from =last= to find the end of the chain, then
walks the chain backwards, printing each name.

#+name: words
#+begin_src b4a
:words                             # list known words, starting at last entry:
  last
  .w du lb 0 eq nt .d              # we are looking at a non-0 pointer to entry
    du e-nm
    puts sp                        # emit str
    ri .o                          # move to next entry
  zp rt
#+end_src

** looking up a word

#+name: word?
#+begin_src b4a
:word?                             # (s-e)   attempt to find word in dictionary
  dc                               # s - |ts  push s to return stack
  last                             # ..-e|ts  fetch last entry
  .w du lb 0 eq nt .d              # while e!=0 do:
    du e-nm                        #  ..- et|ts     fetch the entry's name (t)
    cd du dc                       #  ..- ets|ts
    s-eq? .i cd zp rt .t           # return e if strings match
    ri .o                          # otherwise, visit next string
  cd zp rt                         # (e|ts - e)
#+end_src

* text i/o

#+name: b4-io-words
#+begin_src b4a
:sp lb 32 tw rt                    # emit space
:nl lb 10 tw lb 13 tw rt           # emit CRLF
#+end_src

#+name: puts
#+begin_src b4a
:puts                              # given address of counted string, write the string
  du rb dc inc                     # push str start to d, len to r (loop counter)
  cd .f du rb tw inc .n
  zp rt
#+end_src

#+name: putn/base
#+begin_src b4a
# reading/writing numbers

:base 10 :digit  '0'1'2'3'4'5'6'7'8'9'A'B'C'D'E'F
#+end_src

#+name: putn
#+begin_src b4a
:putn # (n - )
  du lb 00 eq .i lb '0 tw rt
  .e lb 00 sw                      # ( n-kn) k:digit count=0
     .w du lb 00 eq nt .d          # while n!=0 do
        li `base rb dvm            # (kn-kdm) divmod
        li `digit ad rb dc         # (kdm-kd|c) push char to retn stack
        sw inc sw .o               # k++, d is new n
      zp                           # (kd-k)
      .f cd cd tw dc .n .t         # loop through the characters
  rt

#+end_src


#+name: try-num
#+begin_src b4a
:digit?                            # (c-d1) or (c-0)
 du lb '0 lb '9 between? .i
    zp lb '0 sb n1
 .e zp lb 0 .t
 rt

:try-num                           # (s-n) try to parse string as number
  du rb dc                         # (s    - s|i) a=addr of string
  lb 0                             # (s|i  - sr|i) r=0
  cd .f dc inc du rb               # (ar|i - ac|ri) a=addr of char, c=char
     digit? .i
        cd lb 10 ml ad dc          #  r= r*10+d
     .e unknown
        zp cd zp cd zp rt .t       # drop result and return
     cd                            # (p|ri - pr|i) so next can do its thing
  .n
  sw zp rt                         # (pr-r)

#+end_src

* the repl
** main logic
#+name: b4-repl
#+begin_src b4a
  # repl

  # shell
  :tok-len 00                        # length of the current token
  :tok                               # 64-byte token buffer
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

  # string cursors
  # !! TODO if i rename s+ this to sw+ all words are unknown. what?! why?
  :s+ vb +S wv rt                    # s+ ( n - ) mem[reg_s++]:n

  :eol 01                            # end of line flag

  :end-token
    lb 01 li `eol wb                 # set the eol flag
    @S li `tok sb                    # calculate length: start of token buffer
    li `tok-len sw ov wb             # save the length
    li `tok !S                       # reset ap to start of buffer for next time
    rt

  :repl .w lb 01 .d
    li `eol rb .i                    # if end of line flag
      lb 00 li `eol wb b4> .t        # show prompt if new line
    tr                               # read char from terminal
    du lb '` eq .i db .t             # ` = debugger
    du lb 32 eq .i tw                # on space,  (echo space and add dummy char)
      end-token
      du word?                       #    look up the word
      du lb 0 eq .i zp try-num       #    if not found, complain
      .e sw zp exec .t               #    else execute
    .e
      lb 31 ov lt .i du du s+ tw     # copy non-ctrl chars to buffer and echo
      .e du lb 04 eq .i bye .t       # on ^d, exit
      .t zp
    .t .o
#+end_src

** the prompt
#+name: b4-prompt
#+begin_src b4a
:b4>
  nl lb 02 ta                      # green on black
  lb 'b tw lb '4 tw lb '> tw       # echo 'b4>'
  lb 32 tw lb 07 ta                # gray on black for user input.
  rt
#+end_src

** "bye" word
#+name: bye
#+begin_src b4a
:bye nl lb 01 ta                  # red
  lb 'e tw lb 'n tw lb 'd tw       # echo 'end'
  nl hl
#+end_src

** repl: unknown word
#+name: unknown
#+begin_src b4a
:unkno-s 13 'u'n'k'n'o'w'n' 'w'o'r'd'.
:unknown
 lb 08 ta sp li `unkno-s puts nl rt
#+end_src

** repl: exec
#+name: dyn-call
#+begin_src b4a
# TODO: push to control stack instead
:dyn-call cl :dyn-adr 00 00 00 00 rt
#+end_src

#+name: exec
#+begin_src b4a
:exec
  e-xt
  li `dyn-adr wi
  dyn-call
  rt
#+end_src

* math library

** public words
#+name: inc
#+begin_src b4a
:inc  lb 01 ad rt
#+end_src

#+name: dec
#+begin_src b4a
:dec  lb 01 sb rt
#+end_src

** private words
#+name: b4-math
#+begin_src b4a

:dvm  # n d
  ov ov md      # (xy-xy|m)
  dc dv cd rt   # (xy|m-dm|)

:between?                          # (x hi lo - x f)
  du dc lt nt                      # (x <=hi? |lo)  (x<=y is -.(y>x))
  ov cd sw lt nt an rt             # (x f)

:n1 lb 00 nt rt                    # TODO: better way to write "-1"

#+end_src

* string compare
#+name: s-eq?
#+begin_src b4a
# string compare
:s-eq?                             # (st-?) are strings s and t the same?
  ov ov eq .i eq rt .t             # a. if the addresses are the same, return 1
  ov rb du dc ov rb eq nt .i       # b. (st-st?|n) if the lengths are different,
     cd zp eq rt .t                #   drop loop counter and return 0 (we know eq=0 from a.)
  cd .f inc sw inc                 # st-TS  -> next char (doesn't matter that we swap order)
     ov rb ov rb eq nt .i          # if the characters are not equal
     cd zp eq rt .t .n             #   drop counter & return 0 (same as b. before)
  zp zp lb 1 rt                    # everything matched, so return 1
#+end_src

* the compiler
#+name: here
#+begin_src b4a
:here  lb 12 rt
#+end_src

#+name: comma
#+begin_src b4a
:, here ri du dc wb
    cd inc here wi rt              # ',' is same as 'a+' but for heap
#+end_src

* the memory manager
** private words
#+name: b4-mm
#+begin_src b4a
# memory management

# this is meant to be a separate area from the main forth heap.
# the forth heap is basically unmanaged, contiguous memory.
# this area is meant for dynamicaally allocated buffers.

:m0 li 00 02 00 00 rt                 # $0200 = addres 512 (little-endian)
:mm-next rt
:mm-size lb 04 ad rt                  # field for size of the block, in bytes
:mm-used lb 08 ad rt                  # field for used amount (in bytes)
:mm-data lb 12 ad rt
:mm-split lb 10 ad rt                 # split blocks if at least this many bytes left

:mm-init
  lb 00 m0 mm-next wi                 # initial 'next' is 0 (null)
  lb 01 lb 12 sh m0 mm-size wi        # initial size (1<<12 = 4kb) TODO: calculate this
  lb 00 m0 mm-used wi                 # initial used = 0
  rt


:mm-align                             # (n-n) align n to cell size
  lb 04 ov lb 03 an sb lb 03 an       # (n-nk) k= (4-(n&3))&3
  ad rt                               # (nk-a)


# memory management -- alloc / free

:mu 00 00 00 00 :ms 00 00 00 00       # local variables for alloc
:mp 00 00 00 00

:mm-claim                             # (-a) claim mp (and possibly split end off)
  @mp mm-used @mu wi                  # (-) mem[a] := used
  @mp mm-size ri @ms sb               # (-r) remainder = block size - size
  mm-split ov lt .i                # (r-r) if worth splitting
    # shrink old block:
    @ms @mp mm-size wi                # (r-r) mem[mp+SIZE] = ms
    @mp mm-data @ms ad                # (r-rn) n=(mp+DATA)+ms  (n=new next)
    du @mp mm-next du ri dc wi        # (rn-rn|o) mem[mp+NEXT]=n, o=old next
    # add new block:
    du mm-next cd wi                  # (rn|o-rn) mem[n+NEXT]=old_next
    sw lb 0 mm-data sb                # (rn-nz) z: new size (remainder-header size)
    ov mm-size wi                     # (nz-n) mem[n+SIZE]=z
    mm-used lb 0 wi .t                # (n-)  mem[n+USED]=0
  @mp rt                              # (-a) address of block

#+end_src

** public words
#+name: mm-claim
#+begin_src b4a

#+end_src


#+name: mm-alloc
#+begin_src b4a
:mm-alloc                             # (n-a) allocate block of n bytes
  du !mu                              # (n-) store needed buffer size in mu(sed)
  mm-align !ms                        # (n-) round up to word and store in ms(ize)
  m0 !mp                              #  p = pointer (set to start block)
  :mm-loop
    @mp @ms mm-size lt                # if mn < mem[p+SIZE]
       @mp mm-used ri lb 0 eq an      #    and mem[p+USED]=0
    .i @mp mm-claim rt
    .e @mp mm-next ri                 # consider p^.next
       du @mp lb 0 eq .i rt           # if next=null return null
       .e !mp .t .t                   # else update p
  jm `mm-loop
#+end_src


#+name: mm-free
#+begin_src b4a
:mm-free                              # (a-) deallocate block
  lb 0 wi sw                          # (a-0a)
  lb 0 mm-data sb mm-used ri ad       # (0a-b) b=(a-DATA)+USED
  wi rt                               # mem[b]:0
#+end_src

* initial dictionary
#+name: initial-words
#+begin_src b4a :noweb yes :noweb-prefix no
  :ri vi rv rt  :rb vb rv rt  :wb vb wv rt :wi vi wv rt  # temp hack. inline these soon (?)
  .^ 04 'l'a's't
    <<last>>
  .^ 03 'i'n'c
    <<inc>>
  .^ 03 'd'e'c
    <<dec>>
    <<b4-math>>
    <<b4-io-words>>
  .^ 03 'b'y'e
    <<bye>>
    <<b4-prompt>>
  .^ 04 'p'u't's
    <<puts>>
  .^ 04 'e'-'n'm
    <<e-nm>>
  .^ 04 'e'-'x't
    <<e-xt>>
  :words^ .^ 05 'w'o'r'd's
    <<words>>
    <<dyn-call>>
  .^ 04 'e'x'e'c
    <<exec>>
  .^ 04 's'-'e'q
    <<s-eq?>>
  :word?^ .^ 05 'w'o'r'd'?
    <<word?>>
    <<unknown>>
    <<putn/base>>
  .^ 04 'p'u't'n
    <<putn>>
    <<try-num>>
    <<b4-mm>>
  .^ 04 'h'e'r'e
    <<here>>
  .^ 01 ',
    <<comma>>
  .^ 08 'm'm'-'a'l'l'o'c
    <<mm-alloc>>
  .^ 07 'm'm'-'f'r'e'e
    <<mm-free>>
#+end_src

* string table

This just gives names to strings that appear in output.
Since they just happen to match words already in the dictionary,
these should probably just be inlined or turned into a macro.

#+name: string-table
#+begin_src b4a
# string table
:words-s li `words^ e-nm rt
:word?-s li `word?^ e-nm rt
#+end_src
