# pre: parsing and regular expressions
# inspired by
# https://tinlizzie.org/VPRIPapers/tr2008003_experimenting.pdf
# https://www.bradrodriguez.com/papers/bnfparse.htm

# -- these three copied from bios
:ch @K rb rt                    # current character
:nc @K c1 ad du !K rb rt        # next character
:la @K ad rb rt                 # look ahead n chars
# -- end bios copy

:pre @S !K n1 !M rt             # set k=s, m=-1
:fw @K ad !K rt                 # (n-) inc ^K by n

:m0 c0 !M rt     :m1 n1 !M rt   # m0/m1 set match bit
:ln @K @S sb rt                 # ln(-n) match length
:m! @M nt .i zp cd zp .t rt     # zap arg + exit if m0

:k( @K rt                       # save @K on data stack
:k) @M .i zp .e !K .t rt        # drop or restore saved @K

:m| @M .i zp cd zp              # m|(k-?k) alt guard
       .e du !K .t rt           # must use btween k( .. k)

:chr m! ch eq du !M             # (c-) match char, @K++
   .i c1 +K zp .t rt

:s> c1 +S rb rt                 # inc s and read byte
:brkf cd cd zp c0 dc dc rt      # break .f loop (set ctr=0)

:chs m! @S dc !S m0             # chs(s-) match any char in s
   s> .f s> ch eq .i            # if any char matches:
      m1 nc zp brkf .t          #    match it and break
   .n cd !S rt

:lit m! @S dc !S                # lit(s-) match all chars in s
   k( s> .f                     # (s-Kc) for length of str
      ch s> eq nt               # if any char DOESN'T match:
      .i m0 brkf                #    fail and break
      .e nc zp .t
   .n cd !S k) rt

:opt rt # opt ("?")
:rep rt # rep ("+")
:orp rt # orp ("*")

# -- code I want to write, to match a hex number
:digit k( .[ ."0123456789" .] chs k) rt
:hexit k( digit m| .[ ."ABCDEF" .] chs k) rt
:num   k( .[ .[ '- .] chr .] opt .[ hexit .] rep k) rt
