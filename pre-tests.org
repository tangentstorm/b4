#+title: pre: parsing and regular expressions

* intro

This is a test suite for [[bios/pre.b4a]], a parsing and
regular expression toolkit for the b4 virtual machine.

* TODO fix this dumb bug
#+name: tanco.bug
#+begin_src b4a
first test gets skipped due to bug in the test runner
#+end_src


* =m0 (-)= and =m1 (-)= set the match bit.
#+name: pre.m
#+begin_src b4a
  > m1 @M ?d zp
  ds: [-1]
  > m0 @M ?d zp
  ds: [0]
#+end_src

We will use the =@M= register to track whether
or not a pattern match has succeeded.

For brevity, the words =m0= and =m1= set this flag.

=m1= also doubles as the command to match an empty
string.

* =ln (-n)= : match length
#+name: pre.ml
#+begin_src b4a
  > :S :K .. .. ..
  > ln ?d zp
  ds: [0]
  > :S .. .. .. :K
  > ln ?d %q
  ds: [3]
#+end_src

=@S= marks the start of the current token,
and =@K= points to the current input character.
Subtracting =@S= from =@K= gives us the match length.

* =fw (n-)= : move =@K= forward n characters
#+name: pre.fw
#+begin_src b4a
 > pre ln ?d zp
 ds: [0]
 > c4 fw ln ?d %q
 ds: [4]
#+end_src

* =pre (-)= : initialize parsing and regular expressions
#+name: pre.pre
#+begin_src b4a
  > c4 !S m0       # set values we DON'T want
  > pre @K @M ?d   # init
  ds: [4 -1]
#+end_src

The word =pre= sets =@K= to =@S= and =@M= to -1.

* =m! (x-x?)= : match guard
#+name: pre.m!
#+begin_src b4a
  > :A m! c4 rt
  > m0 c2 ^A ds
  ds: []
  > m1 c2 ^A ds
  ds: [2 4]
#+end_src

The word =m!= causes a word to drop its argument and exit early
if =@M= is 0. (it works by popping one return value off
the control stack and then returning).

* =chr (c-)= : match exact character
#+name: pre.chr
#+begin_src b4a
  > :S :K "hello"
  > :Y lb 'h chr rt # should match and increment k
  > # first test the match guard:
  > m0 ^Y @M ln ?d zp zp
  ds: [0 0]
  > m1 ^Y @M ln ?d zp zp
  ds: [-1 1]
  > @S !K           # reset pointer
  > :N lb 'x chr rt # should not match
  > ^N @M ln ?d zp zp
  ds: [0 0]
#+end_src

=chr= sets the match bit according to whether or not the
current character =ch= matches the value on the stack.

=chr= should use =m!= internally and match only if =@M= is set.

If so, it increments =@K= by one position by calling =nc=.

* =chs (s-)= : choose from character set
#+name: pre.chs
#+begin_src b4a
  > :S :K "54go"
  > :digits ."0123456789"
  > :G li `digits chs rt
  > # remember the match guard!
  > m0 ^G @M ln ?d zp zp
  ds: [0 0]
  > m1 ^G @M ln ?d zp zp
  ds: [-1 1]
  > m1 ^G @M ln ?d zp zp
  ds: [-1 2]
  > ^G @M ln ?d zp zp
  ds: [0 2]
#+end_src

=chs= takes the address of a string of acceptable characters,
and succeeds if any of the charecters match.

=chs= should call the match guard

* =lit (s-)= : match literal string
#+name: pre.lit
#+begin_src b4a
  > :S :K "hello"
  > :Y .[ ."he" .] lit rt
  > m0 ^Y @M ln ?d zp zp
  ds: [0 0]
  > m1 ^Y @M ln ?d zp zp
  ds: [-1 2]
  > @S !K
  > # if only partial match, we have to roll @K back
  > :N .[ ."help" .] lit rt
  > ^N @M ln ?d zp
  ds: [0 0]
#+end_src

=lit= takes a string to match and succeeds if every
character in the input matches exactly.

It's there to save you from having to write a long
sequence of =chr= operations.

Note that if lit succeeds, =@K= advances by the length
of the match, but if it fails, =@K= must go back
where it started.

* =k(= and =k)= : backtracking wrappers
#+name: pre.seq
#+begin_src b4a
  > :S :K .. ..
  > :A k( m0 c4 +K zp k) rt
  > :B k( m1 c4 +K zp k) rt
  > ^A ln ?d zp
  ds: [0]
  > @S !K
  > ^B ln ?d %q
  ds: [4]
#+end_src

We will need =lit='s ability to save and restore the
character pointer =@K= from here on out.

We can organize it into two words:

- =k(= starts a sequence, pushing =@K= to the stack.
- =k)= ends the sequence, and either zaps or restores
  the old value of =@K=, depending on the match bit.

* =m| (k-k?)=: alt operator
#+name: pre.alt
#+begin_src b4a
  > :A k( c2 fw m0 m| c4 fw m0 k) rt
  > :B k( c2 fw m0 m| c4 fw m1 k) rt
  > :C k( c2 fw m1 m| c4 fw m0 k) rt
  > :D k( c2 fw m1 m| c4 fw m1 k) rt
  > pre ^A @M ln ?d %R
  ds: [0 0]
  > pre ^B @M ln ?d %R
  ds: [-1 4]
  > pre ^C @M ln ?d %R
  ds: [-1 2]
  > pre ^D @M ln ?d %q
  ds: [-1 2]
#+end_src

We want to create patterns with multiple rules, so we'll
use the =m|= operator to seperate alternatives.

The logic is similar to the reverse of the match guard =m!=:
- if =@M=, exit the sequence (since there's no need to test
  alternatives if we already have a match)
- otherwise, call =m1= to prep the next alternative.

If we call =m|= between =(k= and =k)= , then we also need to
handle the old copy of =@K= on the stack. To simplify things,
we'll follow the rule to ONLY call =m|= between these
other words.

So in addition to the above:

- if =@M= is true, =zp= the old copy of =@K= off the data stack
- otherwise, keep it on the stack but also reset =@K=.

* =opt (p-)= : optional match (regex =?=)
#+name: pre.opt
#+begin_src b4a
  > :G  .[ lb 'c chr rt .] opt rt
  > :S 'c  # ^G should match and advance 1
  > pre ^G @M ln ?d %R
  ds: [-1 1]
  > :S 'x  # ^G should match but not advance
  > pre ^G @M ln ?d %R
  ds: [-1 0]
#+end_src

The =p= in the stack comment indicates that =opt= takes another
parser as an argument. =opt= always succeeds but doesn't
consume any characters unless the underlying parser matches.

* =rep (p-)= : repeat one or more times (regex =+=)
#+name: pre.rep
#+begin_src b4a
  > :G  .[ lb 'a chr rt .] rep rt
  > :S 'c  # ^G should fail
  > pre ^G @M ln ?d %R
  ds: [0 0]
  > :S "abc"  # ^G should match 1 char
  > pre ^G @M ln ?d %R
  ds: [-1 1]
  > :S "aardvark"  # ^G should match 2
  > pre ^G @M ln ?d %R
  ds: [-1 2]
#+end_src

=rep= is the =+= operator in regular expressions. It must match
at least once, then as many times as possible.

* =orp (p-)= : optional repetition (regex =*=)
#+name: pre.orp
#+begin_src b4a
  > :G  .[ lb 'a chr rt .] orp rt
  > :S 'c  # ^G should succeed but match 0 chars
  > pre ^G @M ln ?d %R
  ds: [-1 0]
  > :S "abc"  # ^G should match 1 char (same as before)
  > pre ^G @M ln ?d %R
  ds: [-1 1]
  > :S "aardvark"  # ^G should match 2 (same as before)
  > pre ^G @M ln ?d %R
  ds: [-1 2]
#+end_src

=orp= is the combination of =opt= and =rep=. It matches its pattern 0 or more times.

* =mhex= : match an uppercase hex number
#+name: pre.mhex
#+begin_src b4a
  > :S "-123" ..
  > pre mhex @M ln ?d %R
  ds: [-1 4]
  > :S "123" ..
  > pre mhex @M ln ?d %R
  ds: [-1 3]
  > :S "-ABCDEF0123456789" ..
  > pre mhex @M ln ?d %R
  ds: [-1 11]
  > # do not match lowercase!
  > :S "abcedef01234567890" ..
  > pre mhex @M ln ?d %R
  ds: [0 0]
  > :S "-no" ..
  > pre mhex @M ln ?d %R
  ds: [0 0]
#+end_src

Putting the pieces together, =mhex= matches an uppercase hex number,
followed by  hex number.
