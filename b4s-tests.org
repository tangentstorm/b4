#+title: b4s: a lisp-like language in b4a

* TODO tanco skips first test
#+name: skip
#+begin_src b4a
(tanco bug makes this skip)
#+end_src

* ensure BIOS is loaded
#+name: b4s.bios
#+begin_src b4a
  > cscr 'o ^O 'k ^O sp B4 putn \0 %q
  ok B4
#+end_src

Assuming the bios is loaded, the above line clears
the internal video screen and prints 'ok B4'.

The `\0` word prints out the first line of video memory.
See [[file:bios-tests.org][bios-tests.org]] for more info.

* nil
#+name: b4s.cells
#+begin_src b4a
  > inic
  > @numc ?d zp
  ds: [3FF]
  > @numc 8 ml @fst^ ad   # nil should be in cell 400
  > @nil^ eq ?d zp
  ds: [-1]
  > @nil^ nil eq ?d zp
  ds: [-1]
  > @nil^ nil? ?d zp
  ds: [-1]
  > %q
#+end_src

Nil is a special cell that marks the end of the list,
and is also used to indcate false.

* car and cdr (nil)
#+name: b4s.nil-parts
#+begin_src b4a
  > inic
  > nil car nil?
  > nil cdr nil?
  > ?d %q
  ds: [-1 -1]
#+end_src

Every cell is a pair of values.

Traditionally, the first of the pair is called the "car"
and the second is called the "cdr" (rhymes with 'footer').

Nil's car and cdr both point back to nil.

* celn
#+name: celn
#+begin_src b4a
  > inic
  > nil celn ?d zp  # nil is -1
  ds: [-1]
  > @fst^ celn ?d zp
  ds: [0]
  > # last (non-nil) cell should have number (numc-1)
  > @end^ 10 sb celn
  > @numc c1 sb eq ?d %q
  ds: [-1]
#+end_src

The function =celn= can be used to map a cell back to its number.
This is only intended for use by these tests, so that we can test
cell adddresses without refering to exact memory locations.

* =inic= and =nxt^= : pointer to next free cell
#+name: b4s.nxt^
#+begin_src b4a
  > inic
  > @nxt^ celn ?d zp   # next cell should be cell 0
  ds: [0]
  > @nxt^ car celn ?d zp
  ds: [1]
  > @nxt^ car car car car celn ?d zp
  ds: [4]
  > # car of last cell in list should be nil
  > @end^ 10 sb car nil? ?d %q
  ds: [-1]
#+end_src

The =inic= routine's last job is to link the allocated
cells together into a list of free cells, storing the
address of the first free cell in @nxtc.

At start, the first free cell should be the first cell,
and its car should point to the next cell (which is the
address 8 bytes ahead).

* =nxtc= : take next cell from free list
#+name: b4s.nxtc
#+begin_src b4a
  > inic
  > # next free should be cell 0
  > @nxt^ celn ?d zp
  ds: [0]
  > # if we take it, then next up is cell 1
  > nxtc celn @nxt^ celn ?d %q
  ds: [0 1]
#+end_src

We can take the next cell from the free list with =nxtc=,
which will put the current value of =nxt^= on the stack, and
cause the =nxt^= to move to the next cell in the list.


* =cnum= / =pnum= : construct and print a lisp number
#+name: b4s.nums
#+begin_src b4a
  > inic
  > 7C cnum du pnum \0 cscr
  7C
  > celn ?d %q
  ds: [0]
#+end_src

We have to wrap plain b4 numbers in cells in order to use them in b4s.

=cnum= encloses a plain b4 number in a cell.

=pnum= prints the numeric cell (depends on =putn= from the bios).

* =glu= and =o4c= : symbol helpers
#+name: b4s.sym-helpers
#+begin_src b4a
  > 's 'y 'm '! ?d        # four ascii characters
  ds: [73 79 6D 21]
  > glu ?d                # glue together as symbol
  ds: [216D7973]
  > o4c ?d \0 %q          # o4c calls ^O on each non-zero char
  ds: []
  sym!
#+end_src

For now, symbols are limited to 4 ascii characters, which are packed
together into a standard int32.

* =csym= / =psym= : construct and print symbols
#+name: b4s.syms
#+begin_src b4a
  > inic
  > 't 'a 'c 'o ?d
  ds: [74 61 63 6F]
  > glu csym du psym \0 cdr ?d
  ds: [6F636174]
  taco
#+end_src

Symbols are stored in the cdr of a cell, just like a b4s number.




* TODO [0/7] the printer
** TODO pnum: print a lisp number from a cell
** TODO put4: print a raw symbol (4 bytes)
- we could come up with fancy encoding to pack 5 letters (no uppercase)
- but easier to just chain them together later
- also 8-bit ascii works much nicer with the assembler and memory view
** TODO p4ch: print 4 chars of a symbol
** TODO pval (=^P=): print an arbitrary value
** TODO plis: print a list
** TODO vtyp: type code extractor

* TODO [0/3] the allocator (cons)
** TODO cels
** TODO ncel
** TODO cons

* TODO [0/4] the reader
** TODO rnum
** TODO rsym
** TODO rlis
** TODO rval (=^R=)

* TODO [0/2] eval
** TODO eval
- start here because syms, nums, and nil eval to themselves
** TODO elis
* TODO mention wipe/tag?/type codes
