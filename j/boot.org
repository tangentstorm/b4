#+title: bootstrapping a forth-like system

* INTRO (why bother bootstrapping?)
- narrative so people (including me) can understand what's happening
- tool for others to follow along (and get exact same results)
- you don't have to already know forth or assembly to follow along.
- we're just going to make up whatever we need or what we want the bytecode to be
- it doesn't matter what the vm looks like, because in the end we'll have a forth, and we can use that to write a more advanced assembler.
- once you have your b4, you'll understand it completely, and you can make changes to tailor it to your own system.
- you can follow the trail and implement the virtual machine to learn your new language or chip or whatever, and then you can use my tools.
- (hopefully someday b4 itself will be able to guide you through implementing the b4 vm in a new environment, but these can still serve as test cases along the way)
- maybe people will understand my stuff and make it better or contribute tools
- just seems like fun. :)
- it's really hard to bootstrap and figure this out, which is why most people just use the completed tools, but then that shifts the burden to new people trying to understand the system. by leaving a trail, maybe it'll make a smoother onramp for someone trying to understand b4, or just to bootstrap their own system.

* GOALS

1. I want to bootstrap a small repl on a forthlike system.
It should be handy for symbolic processing of source code.

2. I want this to be something that's easy to follow and easy to present,
for other people wanting to work on their own forth implementations.

More importantly, I want some kindof *feedback* from the system at each step.
This is probably the main thing missing in most bootstrapping stories I've
encountered: you have to do lots of steps before you get any feedback from
the system.

So instead, let's focus on clearly defined checkpoints
that don't take much work to reach.

* REQUIREMENTS
- dictionary
- lookup  : word as string -> address return 0
- execute : execute the word you looked up
- compile : write a call to the word you looked up

* CHECKPOINTS
** establish input/output (native code on host machine)
*** hello world
determine how we will perform output
*** echo input
determine how we will perform input
determine end of input

(for vm, can use input/output wrapper, where host language
reads from stdin, copies to input buffer, waits for response,
and posts to output buffer)

** assembler(s)
*** TODO a0 onboard hex code assembler
**** help us learn the basic techniques
establish file input/output protocol. simple hex parser
**** handle spaces
**** lookup character in string
**** compose every two nibble chars
**** write to output buffer
*** TODO a1 add muri style mnemonics
**** recognize a mnemonic
***** :nextc (-c) scan for next non-space character
***** nextc twice
***** do they match an op?
***** else fall back to hex
*** TODO a2 1 char labels, hops, and comments
hops are relative. we have a jump instruction,
but addresses don't fit in two characters.
so, might need multiple hops to make a long jump.
hop allows position independent code.
*** TODO a3 forth-style dictionary / compiler
** interpreter(s)
*** TODO b0 a1 (mnemonic) interpreter in a3
*** TODO b1 add basic forth vocabulary
*** TODO b2 sigils/classes (from retroforth)
*** TODO b3 combinators ?
*** TODO b4 (real, evolving language with std library)



* PREPARATION
We should have templates for doing basic things:

** ops used
00 ^b ^[ ^]
si sw ov du zp go
dr rd
rb wb
zd dz zw
hp h0 rt
ad su eq

** macros used:
!b write byte (probably going to be a plain op)

![ quote compiler
!] end quote compiler
!d do
!e else
!f for
!i if
!j loop index
!k next token
!n next
!o od
!r rotate
!s string search
!t then
!w while
!z fi


** DONE [4/5] basic control flow templates, based on the basic programs from [[#APTOP]]
*** note: register =Z= contains the address we're writing to as we assemble.
*** DONE 'ok' does nothing, so no bytecode is emitted and it isn't used in the assembler. (' ' works)
*** DONE =!i .. !t .. !e .. !z= provides conditionals
**** =!i= is ~[ ( - ) ]~
"If" is pretty much a no-op and only there for human readers.
**** =!t= ("then")  is ~[ ( -z) si h0 zw si 00 zw zd ]~
~[ si h0 zw ]~ emits the opcode for h0
~[ si 00 zw ]~ emits the byte 0
~[ zd ]~ is the opcode that puts the address in register Z onto the stack

We want to jump if the condition is /false/, but at compile time, we don't know where we're jumping yet, so we need to leave some space for the jump target, and also push the current position onto the stack so we can come back and fill it in later.
**** =!z= ("endif") is ~[ (a- ) du zd sw su ^b ]~
- if the input we're assembling is well formed, address =a= of the hop distance from =th= should still be on the stack. So now:
- =(a- aa)=  du  duplicate a
- =(.. aaz)= zd  take the new address in z
- =(.. aza)= sw  swap them
- =(.. ad)=  su  subtract to get the distance between =a= and =Z= (and thus how far to jump)
- =(.. )=    ^b  writes a single byte to an address, while preserving =Z=

**** =!e= ("else") is ~[ (a-z) si hp zw     si 00 zw     sw ov  !z ]~
( a-az)  hp, 0, zd  - unconditional hop to fill in later (jump from end of then to end of else)
(.. zaz) sw ov      -
(.. z)   fi         - we jump to 'el' branch if condition after 'th' is false, which is
                      the same logic as jumping to the end of if..fi so we can just call fi here.
                      the difference is we're keeping another address on the stack for the
                      next =fi= to fill in.

**** =!b= (helper macro) writes a single byte to an address, while preserving Z
 sw (ab-ba)
 zd (.. baz)
 sw (.. bza)
 dz (.. bz) and Z'=a
 sw (.. zb)
 zw (.. z) and M[a]=b
 dz (.. ) restoring Z
*** DONE =!w .. !d .. !o= provides while loops
**** =!w= is ~[ (  -w) zd ]~
**** =!d= is ~[ (  -d) !t ]~
**** =!o= is ~[ (wd- ) sw si hp zw zd sw su zw fi ]~
(wd-dw)  =sw=
(.. dw)  =si hp zw=  emits 'hop' instruction
(.. dzw) =zd sw=
(.. dv)  =su= calculate hop vector v: backward jump of distance z-w to the 'wh' address
(.. d)   =zw= emits v as the argument to =hp=
(.. )    =fi= fills in the jump over the loop from 'do' if the condition fails.
*** DONE =![= .. =!]= for compiling multiple ops
=![= - offset of the ![ in the source is already in y, since we're assembling.
     - no need to preserve y, since we're still reading the same source
     - no need to preserve z, since we're still emitting to the same place
   - ~bw ^[ !w !k du ![ FF 1C !] ad ne !d ![ si !] zw !o zp rt go~
=!]= - does nothing. it's just used as an end marker.

*** TODO =!f .. !n= is a for loop
**** TODO =!f= is [ (a-) zd si dr zw ]
**** TODO =!n= is [ (a-) ]

rd             # counter to stack
^[ si 01 ad ^] # compile these
si hp zw zw    # loop




nx =: (hp@rput@<:)`incp@.(0-:])@ rpop  NB. 'next': if (rtos--)==0 proceed, else hop
]
** DONE =bw ^c .. =go= binds a 'word'(ascii control character) to the next address
as in forth, a word can act as a function, constant, or variable

** TODO [0/4] extra credit
*** TODO =ef= for 'else if' ... maybe this is just =el=, since =if= is a no-op?
*** TODO fn : implementing function arguments
- op 'ac s' would specify up to four arguments
  - s would be a signature byte
    - 2 bits specify number of args (up to 4)
    - 4 bits specify which ones to preserve
    - 2 bits left over for some other purprose
      - ex: you could pass up to 16 arguments, only the last 4 could be writable
      - but you probably just don't need this.
      - you might want 1 bit for 'is recursive'. (see below)
  - inside the definition, allocate n cells
  - push the first n control registers to the return stack
  - (if the function is recursive, you also have to push the cells onto the return stack)
  - set ^A to address of first cell, ^B to next, etc.
  - move the four values from the stack to the cells
  - now inside the function, you can use ^A ^B ^C ^D to refer to the args.
  - before returning, restore the arguments
- all this means more work as part of the protocol, but less stack juggling
*** TODO =rp .. un= : repeat until
*** TODO =case= case / switch statement for scalars
- with or without fallthrough (no fallthrough means you can reorder)
- with range matching
** TODO 2-char assembler
*** remove all whitespace/comments
*** loop through and emit 1 byte per 2-char token
**** if first char is ', emit the next byte
**** =^= indicates a ctrl char. if next char is a-z, subtract ord('a') and emit, else emit 0.
**** if char in list of first chars of opcodes:
***** test next against list of second chars for opcodes starting with the first char
***** use index into a corresponding lookup table
***** (if no match, emit 0)
*** otherwise treat as two hex digits (again, string lookup)
** DONE =^r= ("rotate") is ~[ (abc-cab) sw dr sw rd ]~
: (abc-acb) sw
: ( .. ac)  dr # push b to return stack
: ( .. ca)  sw
: ( .. cab) rd # return b

** TODO =^s= ("string search") is
find index of char =c= in string (address) =s=
: (cs-csl)            # goal:
: (.. csl)   du rb    # fetch length of the string
: (.. cs)    dr       # push len(s) to return stack, as loop counter
: (.. )
: (cs- )
  # actual b4a instructions:
  # for = dr
  # ii  = rd
  >H `0`1`2`3`4`5`6`7`8`9`A`B`C`D`E`F
  >h (c-n) # convert hex char c to 00,..10
    &H y!
    yr for             # loop through chars of HEX
      du               # copy c
      [ yr eq :        # if c = HEX[ix]  (ix=(#HEX)-ii)
        zp             #  drop c, and find ix
        &H rb          #  fetch one byte (the len), # TODO:relative
        rd             # 'ii'=rd (look at loop counter)
        sb             # len-ii = ix = the result
        rt
      ]
    nx
    0 rt



** common operations
*** hash a string
*** compare two strings
*** traverse a linked list
*** find value in lookup table

* IMPLEMENTATION
** a0 : hex assembler
*** recognize a single hex digit
#+begin_src python

  HEX = '0123456789ABCDEF'

  # normal python:
  def hexit(c):
      return max('0123456789ABCDEF'.find(c),0)

  # vm environent:
  x = y = z = 0  # registers
  d = []         # data stack
  r = []         # return stack
  m = ['...#0123456789ABCDEF']  # m = ram, # is len (15) 0-F ascii chars
  d = [c]                       # d = stack, c= char to lookup

  def rput(v): r.append(v)
  def yr(): m[r]

  def hexit:
     # i counts down from 15 to 1
     y = m.index('#')

     for i in range(m[y],1):      # si 0F dr  (loop counter goes on return stack)
         y = HEX+y              # rd
         d.append(HEX[y])
         # set y=hex+i  si 01 yd ad
         if d[-1] == HEX[r[-1]]:
            break
        else: r[-1] -= 1
     d.push(r.pop())
     return

  # actual b4a instructions:
  # for = dr
  # ii  = rd
  >H `0`1`2`3`4`5`6`7`8`9`A`B`C`D`E`F
  >h (c-n) # convert hex char c to 00,..10
    &H y!
    yr for             # loop through chars of HEX
      du               # copy c
      [ yr eq :        # if c = HEX[ix]  (ix=(#HEX)-ii)
        zp             #  drop c, and find ix
        &H rb          #  fetch one byte (the len), # TODO:relative
        rd             # 'ii'=rd (look at loop counter)
        sb             # len-ii = ix = the result
        rt
      ]
    nx
    0 rt

#+end_src


  def a0(s):
     x = 0
     for c in s:
        if c <= ' ': continue
        else:
           hexit()
           x = ~x
           if x:


* -- extra stuff --

* (draft) explaining what a forth is

A forth system has the following variables:

   HERE : address of first cell of usable ram
   LAST : address of last defined word record
   IBUF : adresss of the input buffer

message passing system:

  declare an input buffer containing a short string:
    1 byte length/mutex
    255 input bytes
  if length=0, interpreter is ready for input
  client fills in the memory and sets leading byte to length.

interpreter:

  tokenize input and handle each token.
  special leading characters:
    : define word
    & obtain pointer
    ( comment
    ` assembler
    @ getter
    ! setter
    0..9       (decimal)
    $ hex      (retro: char)
    # comment  (retro: number)
    [ block    (retro: n/a)

* template for hex code assembly programs
#+begin_src b4a
#0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _A _B _C _D _E _F
hp 10 .. .. .. .. .. .. .. .. .. .. .. .. .. ..
.. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..
.. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..
#+end_src

* how this exercise affected b4 design
- hex dumper: i probably won't actually use it (since it isn't necessary to GENERATE a hex dump), but i started with this exercise in mind, and once i started writing it in hex+mnemonic assembly style, i was annoyed at how much space i was wasting with packed instructions followed by long addresess. This prompted me to switch to just using a bytecode, and not worry about 32-bit cells.
- hex assembler:  this made me want to do xr as well as yr, to make it easy to compare strings, but i didn't (yet)

* note on grimley's code
this follows his lead
he was using x86, because that's the system he was on
but that's kind of an accident of history.
i'll use a virtual bytecode interpreter)
(which we can implement in any language)
* hex dump
# probably want a disassembler if I reorder the opcodes, or for a debugger
# but probably don't need this for the bootstrapping process
** program to generate hex dump of tos
** break off a digit
#+begin_src b4a

:nibl (x-xd)  # extract next nibble
du si 0F an   # x → xx → xxF → xd  (where d=x & F)
sw si 04 sr   # xd → dx → dx'      (where x'=x>>4)
rt .. .. ..
#+end_src

** break off all 8 digits
: jump, loop, or macro, or duplicate code ?
#+begin_src b4a
# break tos into 8 hex digits
dusi0Fanswsi04sr dusi0Fanswsi04sr dusi0Fanswsi04sr dusi0Fanswsi04sr
dusi0Fanswsi04sr dusi0Fanswsi04sr dusi0Fanswsi04sr dusi0Fanswsi04sr
zp

# or, if we can call subroutines:
nibl nibl nibl nibl nibl nibl nibl nibl zap

# or
&nibl 8 times zap

# or:
#+end_src

- we could just repeat the instructions 4 times without the return.
- or we could use a loop

** 0..f -> char
char buf
just use it as index into buffer

* bibliography
** [APTOP] eric hehner, [[http://www.cs.toronto.edu/~hehner/aPToP/][a practical theory of programming]]
:PROPERTIES:
:CUSTOM_ID: aptop
:END:

** edmund grimley evans, [[http://web.archive.org/web/20061108010907/http://www.rano.org/bcompiler.html][bootstrapping a simple compiler from nothing]]
** jonesforth
** retroforth
** kragen sitaker, [[https://github.com/kragen/stoneknifeforth][stone knife forth]] uses a 1-char instruction set

* stackwise approach
- keep it simple: b4-specific for now
- at the top level, you enter a specification
  - a specification is a description of behavior
- definitions only need to be well defined and valid syntax
  - wds =                           -- well defined spec
    - | 'ok'
    - | (var) ':=' (val)
    - | (wds) .. (wds)
    - |  if: (cond) do: (wds)
        (ef: (cond) do: (exp))*
        (el: (exp))? nd.
    - | wh: (cond) do: (wds) en.
    - | fo: (var) in: (exp) do. (wds) en.
    - | (other combinators: @ & ^: etc )

  - also need: definitions for data types, 'classes'

- usage:
  - enter as many type specs as you like
    - obligation: valid syntax,
    - obligation: all referenced names are defined
  - enter as many examples as you like (become test cases)
  - enter a function name
  - give it a name, and that's the first word you have to define
- this generates several obligations:
  - define (specify) all undefined words
  - prove that the word implements the spec
  - implement all unimplemented words
    - can specify these without implementation (for now)
