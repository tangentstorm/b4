#+title: bootstrapping a forth-like assembler

* OUTPUT
This org-mode document, when run through =org-babel-tangle= in emacs, produces two output files, both of which are assemblers for the b3 assembly language, =b3a=.

=b3= is a stripped down version of the =b4= virtual machine, (in development at the time of this writing).
The b3 version provides only the opcodes necessary to run this assembler on itself.

** file:b3a.b3a is b3a assembler written in b3a.
#+begin_src b3a :tangle b3a.b3a :noweb yes
# b3a.b3a : a bootstrap assembler for b4 vm, written in itself.

#= macros =====================================================
<<macros-if>>
<<macros-while>>
<<macros-quote>>
<<macros-for>>

#= runtime ====================================================
<<ctl-c>>
<<ctl-s>>
<<ctl-h>>
<<ctl-k>>
<<ctl-a>>

#+end_src

** file:b3a0.py  is a bootstrap assembler for b3a in python.
#+begin_src python :tangle b3a0.py :noweb yes  :padline no
  #!/usr/bin/env python3
  """
  b3a0.py: a bootstrap b3 assembler in python

  This is a simplfied version of b3a.b3a.

  It does not provide the ability to create macros
  (since that would require a b3 bytecode interpreter).
  Instead, it has hard-coded support for the specific
  macros used in b3a.b3a.
  """
  import re

  <<py-tokens>>
  <<py-macros>>
  <<py-asm>>

  if __name__=="__main__":
      src = open('b3a.b3a').read()
      open('b3a0.out','wb').write(asm(src))

#+end_src

* INTRO (why bother bootstrapping?)
- narrative so people (including me) can understand what's happening
- tool for others to follow along (and get exact same results)
- you don't have to already know forth or assembly to follow along.
- we're just going to make up whatever we need or what we want the bytecode to be
- it doesn't matter what the vm looks like, because in the end we'll have a forth, and we can use that to write a more advanced assembler.
- once you have your b4, you'll understand it completely, and you can make changes to tailor it to your own system.
- you can follow the trail and implement the virtual machine to learn your new language or chip or whatever, and then you can use my tools.
- (hopefully someday b4 itself will be able to guide you through implementing the b4 vm in a new environment, but these can still serve as test cases along the way)
- maybe people will understand my stuff and make it better or contribute tools
- just seems like fun. :)
- it's really hard to bootstrap and figure this out, which is why most people just use the completed tools, but then that shifts the burden to new people trying to understand the system. by leaving a trail, maybe it'll make a smoother onramp for someone trying to understand b4, or just to bootstrap their own system.

* GOALS

1. I want to bootstrap a small repl on a forthlike system.
It should be handy for symbolic processing of source code.

2. I want this to be something that's easy to follow and easy to present,
for other people wanting to work on their own forth implementations.

More importantly, I want some kindof *feedback* from the system at each step.
This is probably the main thing missing in most bootstrapping stories I've
encountered: you have to do lots of steps before you get any feedback from
the system.

So instead, let's focus on clearly defined checkpoints
that don't take much work to reach.

* REQUIREMENTS
- dictionary
- lookup  : word as string -> address return 0
- execute : execute the word you looked up
- compile : write a call to the word you looked up

* TODO CHECKPOINTS  # revisit this
** establish input/output (native code on host machine)
*** hello world
determine how we will perform output
*** echo input
determine how we will perform input
determine end of input

(for vm, can use input/output wrapper, where host language
reads from stdin, copies to input buffer, waits for response,
and posts to output buffer)

** assembler(s)
*** TODO a0 onboard hex code assembler
**** help us learn the basic techniques
establish file input/output protocol. simple hex parser
**** handle spaces
**** lookup character in string
**** compose every two nibble chars
**** write to output buffer
*** TODO a1 add muri style mnemonics
**** recognize a mnemonic
***** :nextc (-c) scan for next non-space character
***** nextc twice
***** do they match an op?
***** else fall back to hex
*** TODO a2 1 char labels, hops, and comments
hops are relative. we have a jump instruction,
but addresses don't fit in two characters.
so, might need multiple hops to make a long jump.
hop allows position independent code.
*** TODO a3 forth-style dictionary / compiler
** interpreter(s)
*** TODO b0 a1 (mnemonic) interpreter in a3
*** TODO b1 add basic forth vocabulary
*** TODO b2 sigils/classes (from retroforth)
*** TODO b3 combinators ?
*** TODO b4 (real, evolving language with std library)



* PREPARATION
We should have templates for doing basic things:

** macros used:
#+begin_src b3a
!b # write byte (probably going to be a plain op)

# assembler macros that anyone can use
![ #quote compiler
!] #end quote compiler
!d #do
!e #else
!f #for
!i #if
!j #loop index
!n #next
!o #od
!t #then
!w #while
!z #fi

# macros
^a invokes the assembler
^l stores length of the input buffer
^r rotate
^c next char
^k next token
^s search (given length byte and starting address)
^x FEDCBA9876543210
^h parse hex pair
^p aabccdddddddeeggghhhhjlllmmnnnooqrrrrrrssssswwxxyyzzz
^q dnwdlcruvxyzqveot01lpmeitdlegtrvp01dmptbilrwmpdrdrdpw

   ,/"2'''',"0|:/:~>ops

#    NB. the total available choices:
#    [ ctl =: tolower a.{~64+i. 32
# @abcdefghijklmnopqrstuvwxyz[\]^_
#    used =: '[]defijknorstwz c'
#    ctl -. used
# @abghlmpquvxy\^_
#+end_src

** DONE [6/6] basic control flow templates, based on the basic programs from [[#APTOP]]
*** note: register =Z= contains the address we're writing to as we assemble.
*** DONE 'ok' does nothing, so no bytecode is emitted and it isn't used in the assembler. (' ' works)
*** DONE =!i .. !t .. !e .. !z= provides conditionals
#+name: macros-if
#+begin_src b3a

# if .. then .. else .. end
bw ^i rt go
bw ^t si h0 zw si 00 zw zd rt go
bw ^e ![ hp 00 !] zd sw ov ^z ev rt go
bw ^z du zd sw sb wb rt go
#+end_src
**** =!i= is ~[ ( - ) ]~
"If" is pretty much a no-op and only there for human readers.
**** =!t= ("then")  is ~[ ( -z) si h0 zw si 00 zw zd ]~
~[ si h0 zw ]~ emits the opcode for h0
~[ si 00 zw ]~ emits the byte 0
~[ zd ]~ is the opcode that puts the address in register Z onto the stack

We want to jump if the condition is /false/, but at compile time, we don't know where we're jumping yet, so we need to leave some space for the jump target, and also push the current position onto the stack so we can come back and fill it in later.
**** =!z= ("endif") is ~[ (a- ) du zd sw sb wb ]~
- if the input we're assembling is well formed, address =a= of the hop distance from =th= should still be on the stack. So now:
- =(a- aa)=  du  duplicate a
- =(.. aaz)= zd  take the new address in z
- =(.. aza)= sw  swap them
- =(.. ad)=  sb  subtract to get the distance between =a= and =Z= (and thus how far to jump)
- =(.. )=    wb  writes the distance byte to the address

**** =!e= ("else") is ~[ (a-z) si hp zw     si 00 zw   zd sw ov  ^z ex ]~
( a-az)  hp, 0, zd  - unconditional hop to fill in later (jump from end of then to end of else)
(.. zaz) sw ov      -
(.. z)   ^z ex      - we jump to 'el' branch if condition after 'th' is false, which is
                      the same logic as jumping to the end of if..fi so we can just call fi here.
                      the difference is we're keeping another address on the stack for the
                      next =fi= to fill in.

*** DONE =!w .. !d .. !o= provides while loops
#+name: macros-while
#+begin_src b3a

# while .. do .. od
bw ^w zd rt go
bw ^d ^t ev rt go
bw ^b zd sw sb zw go   # backwards jump
bw ^o sw ![ hp !] ^b ev ^z ev rt go
#+end_src
**** =!w= is ~[ (  -w) zd ]~
**** =!d= is ~[ (  -d) !t ]~
**** =!o= is ~[ (wd- ) sw ![ hp !] zd sw sb zw !z ]~
(wd-dw)  =sw=
(.. dw)  ~![ hp !]~ →  =si hp zw=  emits 'hop' instruction
(.. dzw) =zd sw=
(.. dv)  =su= calculate hop vector v: backward jump of distance z-w to the 'wh' address
(.. d)   =zw= emits v as the argument to =hp=
(.. )    =!z= fills in the jump over the loop from 'do' if the condition fails.
*** DONE =![= .. =!]= for emitting instructions which emit the ops inside the brackets
#+name: macros-quote
#+begin_src b3a

# quote compiler macro
bw ^[ !w ^k ev du ![ FF 1C !] ad ne !d ![ si !] zw !o zp rt go
#+end_src
=![= - offset of the ![ in the source is already in y, since we're assembling.
     - no need to preserve y, since we're still reading the same source
     - no need to preserve z, since we're still emitting to the same place
   - ~bw ^[ !w ^k ev du ![ FF 1C !] ad ne !d ![ si !] zw !o zp rt go~
=!]= - does nothing. it's just used as an end marker.

*** DONE =n !f .. !n= is a for loop. (count down from n to 0)
#+name: macros-for
#+begin_src b3a

# for-next loop
bw ^f zd ![ dr !] rt go
bw ^n ![ nx !] ^b ev rt go
#+end_src

**** =!f= is ~[ ( -a) zd ![ dr !] ]~
At compile time, it writes the current address to top of ram. (so we can compile the jump later)
At runtime, it pushes the number of times to loop to the return stack.
**** =!n= is ~[ (a-) ![ nx !] zw ]~
*** DONE =bw ^c .. =go= provides both assignment and function definition
binds a 'word'(ascii control character) to the next address
as in forth, a word can act as a function, constant, or variable

* IMPLEMENTATION
** DONE protocol for invoking the assembler
#+begin_src k
/ ibuf and obuf are arbitrary addresses of input/output buffers somewhere in M
/ vm should have already executed the instructions in the assembler binary,
/ and be in calculator mode (since 'hl' gets called at the end)

M[ibuf+!#src] = src
dput ibuf
dput #src
dput obuf
chev 1             / ^a opcode, placing address of assembler on stack
gs[]
o: M[obuf+!tos[]]  / the assembled bytecode output
#+end_src
** TODO [4/6] 2-char assembler
*** DONE =^c= puts the next non-whitespace, non-comment character on the stack
#+name: ctl-c
#+begin_src b3a

bw ^c   # ( -c) fetch next non-whitespace, non-comment character
   !w si 01 !d                       # infinite outer loop
      !w ry du si 20 le !d zp !o     # leave first non-whitespace char on stack
      !i du si '# eq !t              # if it's a "#" character...
         !w ry si 0A ne !d !o        #   loop until we reach a linefeed
      !e rt !z                       # first char was not a "#" so return it
   !o rt go
#+end_src

*** DONE =^s= (csl-i?b) "string search") is []
find index of char =c= in string (address) =s= with length =l=. return 0 if not found, else ix 1
#+name: ctl-s
#+begin_src b3a

bw ^s  # (csl-i?b) search for c in string s with len l
   yd dr              # (csl-csl) copy current read pointer to return stack
   sw dy              # ( .. cl)now start reading from s
   si 00 sw           # ( .. cil)put index on stack under s (!f..!n counts i-- and we want i++)
   !f                 # ( .. ci)   for loop. (at runtime, this pushes length to stack)
      ov ry           # ( .. cicv) copy c, read the byte value from index i
      !i eq !t        # ( .. ci)   if they match..
         rd zp        #   ( .. ci)    remove the loop counter
         rd dy        #   ( .. ci)    restore the read pointer
         sw zp        #   ( .. i)     remove the character from the stack
         si 01 rt     #   ( .. i1)    and return the index and a found=1 flag.
      !e si 01 ad     # ( .. ci')   else add 1 to the index
      !z !n           # ( .. ci')  .. and go on to the next iteration
   zp zp 00 rt go     # ( .. 0) if not found, clear c,i and return 0
#+end_src

*** DONE =^h= parse hex number
#+name: ctl-h
#+begin_src b3a

# ^h : (c-n) hex digit to 00,..15 (capitals only. 00 on fail)
bw ^x '0 '1 '2 '3 '4 '5 '6 '7 '8 '9 'A 'B 'C 'D 'E 'F go
bw ^h !i ^x si 10 ^s ev nt !t si 00 !z rt go
#+end_src

*** TODO =^k= fetches the byte for the next 2-character token, and tags it with a type code
#+name: ctl-k
#+begin_src b3a

bw ^p # firt chars of alphebetized mnemonics
   'a 'a 'b 'c 'c 'd 'd 'd 'd 'd 'd 'd 'e 'e 'g 'g 'g
   'h 'h 'h 'h 'j 'l 'l 'l 'm 'm 'n 'n 'n 'o 'o 'q 'r
   'r 'r 'r 'r 'r 's 's 's 's 's 'w 'w 'x 'x 'y 'y 'z
   'z 'z go

bw ^q # second chars of alphabetized mnemonics
   'd 'n 'w 'd 'l 'c 'r 'u 'v 'x 'y 'z 'q 'v 'e 'o 't
   '0 '1 'l 'p 'm 'e 'i 't 'd 'l 'e 'g 't 'r 'v 'p '0
   '1 'd 'm 'p 't 'b 'i 'l 'r 'w 'm 'p 'd 'r 'd 'r 'd
   'p 'w go

bw ^k  # ( -kt) fetch next token k, with type-tag t
   ^c ev  # fetch first character after whitespace and comments
   !i du si '' eq !t ry si 00 rt !z   # "'x" -> x 0
   !i du si '^ eq !t ry si 01 rt !z   # "^x" -> x 1
   !i du si '! eq !t ry si 02 rt !z   # "!x" -> x 2
   !i du ^p ^s ev !t                  # try matiching an opcode
      # TODO
   !z
   # as a last resort, parse as two (uppercase) hex digits, or 00
   # first digit << 4   # add second digit     return with tag=_1
   ^h ev si 04 sl       ry ^h ev ad si         FF rt go
#+end_src

use ^s to find position of first character in ^x
now count how many copies of that character there are.
now do a ^s inside a bounded range of ^y to match second character

*** TODO code emitter
#+name: ctl-a
#+begin_src b3a
# ^a - the assembler
#+end_src
loop through and emit 1 byte per 2-char token
**** =^= indicates a ctrl char. if next char is a-z, subtract ord('a') and emit, else emit 0.
**** if char in list of first chars of opcodes:
***** test next against list of second chars for opcodes starting with the first char
***** use index into a corresponding lookup table
***** (if no match, emit 0)
*** DONE =^r= ("rotate") is ~[ (abc-cab) sw dr sw rd ]~
#+name: ctl-r
#+begin_src b3a

# ^r is rotate (abc-cab)
bw ^r sw dr sw rd rt go
#+end_src
: (abc-acb) sw
: ( .. ac)  dr # push b to return stack
: ( .. ca)  sw
: ( .. cab) rd # recover b



* BOOTSTRAPPING
** DONE python bootstrap assembler
*** DONE tokenizer
#+name: py-tokens
#+begin_src python

  ## lexer for b3a source code ############################

  OPS = [
      'ad',  'an',  'bw',  'cd',  'cl',  'dc',  'dr',  'du',
      'dv',  'dx',  'dy',  'dz',  'eq',  'ev',  'ge',  'go',
      'gt',  'h0',  'h1',  'hl',  'hp',  'jm',  'le',  'li',
      'lt',  'md',  'ml',  'ne',  'ng',  'nt',  'nx',  'or',
      'ov',  'qp',  'r0',  'r1',  'rd',  'rm',  'rp',  'rt',
      'sb',  'si',  'sl',  'sr',  'sw',  'wm',  'wp',  'xd',
      'xr',  'yd',  'yr',  'zd',  'zp',  'zw' ]

  def bc(t):
      """return the byte code for a mnemonic token"""
      return OPS.index(t) + 0xA0

  def hexit(c):
      """(capital) hex value of c, else 0"""
      return max('0123456789ABCDEF'.find(c),0)

  def tokens(src):
      """src -> [(byte|char, ready?:bit)]"""
      src = src.replace("'#", hex(ord('#'))[2:])  # get rid of '# so # always indicates comment.
      src = re.sub('#.*','',src)                  # get rid of all comments
      for t in src.split():
          if   t[0]=="'": yield (ord(t[1]),    1)
          elif t[0]=="^": yield (ord(t[1].upper())-64, 1)
          elif t[0]=="!": yield (t[1], 0)
          elif t in OPS: yield (bc(t), 1)
          else: yield ((hexit(t[0]) << 4) + hexit(t[1]), 1)
#+end_src
*** DONE macro handlers
#+name: py-macros
#+begin_src python

  ## built-in macros function #############################

  STACK = []

  def SW():
      """swap operation"""
      x = STACK.pop()
      y = STACK.pop()
      STACK.extend([x,y])

  def OV():
      """over operation"""
      STACK.append(STACK[-2])

  def ZD(res):
      """in b3, 'zd' writes the current write position to the stack"""
      STACK.append(len(res))

  def backjump(res, op):
      last = STACK.pop()
      dist = last - len(res) # negative short int
      res.extend([bc(op), 255 & dist])

  # == if/then/else/endif =================================

  def i(res):
      """the IF part of IF .. THEN .. ELSE .. END"""
      # <<ctl-i>>
      # bw ^i rt go
      pass

  def t(res):
      """the THEN part of IF .. THEN .. ELSE .. END"""
      # <<ctl-t>>
      # bw ^t si h0 zw si 00 zw zd rt go
      res.extend([bc('si'), 0])
      ZD(res)

  def e(res):
      """the ELSE part of IF .. THEN .. ELSE .. END"""
      # <<ctl-e>>
      # bw ^e ![ hp 00 !] zd sw ov ^z ev rt go
      res.extend([bc('hp'), 0])
      ZD(res); SW(); OV(); z(res)

  def z(res):
      """the END part of IF .. THEN .. ELSE .. END"""
      # <<ctl-z>>
      # bw ^z du zd sw sb wb rt go
      last = STACK.pop()
      dist = (len(res) - last)
      res[last-1]=dist

  # == while .. do .. od ==================================

  def w(res):
      """the WHILE part of WHILE .. DO .. OD"""
      # <<ctl-w>>
      # bw ^w zd rt go
      ZD(res)

  def d(res):
      """the DO part of WHILE .. DO .. OD"""
      # <<ctl-d>>
      # bw ^d ^t ev rt go
      t(res)

  def o(res):
      """the OD part of WHILE .. DO .. OD"""
      # <<ctl-o>>
      # bw ^o sw ![ hp !] zd sw sb zw ^z ev rt go
      backjump(res, 'hp')
      z(res) # fwd jump when condition fails

  # == for .. next ========================================

  def f(res):
      """the FOR part of FOR .. NEXT"""
      # <<ctl-f>>
      # bw ^f zd ![ dr !] rt go
      ZD(res)
      res.extend([bc('dr')])

  def n(res):
      """the NEXT part of FOR .. NEXT"""
      # <<ctl-f>>
      # bw ^n ![ nx !] ^b ev rt go
      res.extend([bc('nx')])
      backjump(res, 'nx')

  MACROS = {
      'i':i, 't':t, 'e':e, 'z':z,
      'w':w, 'd':d, 'o':o,
      'f':f, 'n':n }

  def quote(res, toks):
      """ quote handler: ( ) """
      # bw ^[ !w ^k ev du ![ FF 1C !] ad ne !d ![ si !] zw !o zp rt go
      for tok,ready in toks:
          if ready: res.append(tok)
          elif tok == ']': return
          elif tok == '[': raise "cannot handle nested ![ .. !]"
          elif tok in MACROS: MACROS[tok](res)
          else: raise "cannot handle '!"+tok+"' inside ![...!]"

#+end_src
*** DONE assembler
#+name: py-asm
#+begin_src python

  ## main assembler function ##############################

  def asm(src):
      res, toks = ([], tokens(src))
      while True:
          try:
              tok, ready = next(toks)
              if ready: res.append(tok)
              else: # macros
                  if tok == '[': quote(res, toks)
                  else: MACROS[tok](res)
          except StopIteration:
              return bytes(res)

#+end_src

** TODO do a topological sort on the macros to see if we can define them directly on the vm
** TODO manually expand any macros we can't macros to get b3a0
** TODO try simplifying macros by having an op 'zz' that sets sleepy=1

* -- extra stuff --

* (draft) explaining what a forth is

A forth system has the following variables:

   HERE : address of first cell of usable ram
   LAST : address of last defined word record
   IBUF : adresss of the input buffer

message passing system:

  declare an input buffer containing a short string:
    1 byte length/mutex
    255 input bytes
  if length=0, interpreter is ready for input
  client fills in the memory and sets leading byte to length.

interpreter:

  tokenize input and handle each token.
  special leading characters:
    : define word
    & obtain pointer
    ( comment
    ` assembler
    @ getter
    ! setter
    0..9       (decimal)
    $ hex      (retro: char)
    # comment  (retro: number)
    [ block    (retro: n/a)

* template for hex code assembly programs
#+begin_src b4a
#0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _A _B _C _D _E _F
hp 10 .. .. .. .. .. .. .. .. .. .. .. .. .. ..
.. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..
.. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..
#+end_src

* how this exercise affected b4 design
- hex dumper: i probably won't actually use it (since it isn't necessary to GENERATE a hex dump), but i started with this exercise in mind, and once i started writing it in hex+mnemonic assembly style, i was annoyed at how much space i was wasting with packed instructions followed by long addresess. This prompted me to switch to just using a bytecode, and not worry about 32-bit cells.
- hex assembler:  this made me want to do xr as well as yr, to make it easy to compare strings, but i didn't (yet)
- real assembler:
  - i originally thought I'd come up with a bunch of helper functions for managing the dictionary:
    - hash a string
    - compare two strings
    - traverse a linked list
    - or otherwise find a value in a lookup table
  - i went to bed quite frustrated after the inital attempt to approach this, which lead me to start by writing macros / templates for the basic structured programming patterns.
  - at first i was going to use special psuedo-opcodes like =if..th..el..en= but after getting frustrated and going to bed, I had the idea of using a set of lettered registers as the dictionary
  - a forth is two stacks and a dictionary, and the dictionary is the hard part to bootstrap.
  - but a simple 1-char dictionary made everything so much easier:
    - the bytecode never needs to refer to absolute addresses
    - since all hops are short, this means the assembler (basically) only has to deal with 8-bit value
    - so we only need 'rb/wb' instead 'rm/wm' - previously these were not opcodes
  - so all this caused me to add 'rb,wb,bw,go' opcodes

* early psuedocode to recognize a single hex digit
was trying to work backwards from a structured programmming approach in python (but using only the equivalent of primative ops in b4). it was very frustrating.
#+begin_src python

  HEX = '0123456789ABCDEF'

  # normal python:
  def hexit(c):
      return max('0123456789ABCDEF'.find(c),0)

  # vm environent:
  x = y = z = 0  # registers
  d = []         # data stack
  r = []         # return stack
  m = ['...#0123456789ABCDEF']  # m = ram, # is len (15) 0-F ascii chars
  d = [c]                       # d = stack, c= char to lookup

  def rput(v): r.append(v)
  def yr(): m[r]

  def hexit:
     # i counts down from 15 to 1
     y = m.index('#')

     for i in range(m[y],1):      # si 0F dr  (loop counter goes on return stack)
         y = HEX+y              # rd
         d.append(HEX[y])
         # set y=hex+i  si 01 yd ad
         if d[-1] == HEX[r[-1]]:
            break
        else: r[-1] -= 1
     d.push(r.pop())
     return

  # actual b4a instructions:
  # for = dr
  # ii  = rd
  >H `0`1`2`3`4`5`6`7`8`9`A`B`C`D`E`F
  >h (c-n) # convert hex char c to 00,..10
    &H y!
    yr for             # loop through chars of HEX
      du               # copy c
      [ yr eq :        # if c = HEX[ix]  (ix=(#HEX)-ii)
        zp             #  drop c, and find ix
        &H rb          #  fetch one byte (the len), # TODO:relative
        rd             # 'ii'=rd (look at loop counter)
        sb             # len-ii = ix = the result
        rt
      ]
    nx
    0 rt

  def a0(s):
     x = 0
     for c in s:
        if c <= ' ': continue
        else:
           hexit()
           x = ~x
           if x:

#+end_src


* note on grimley's code
this follows his lead
he was using x86, because that's the system he was on
but that's kind of an accident of history.
i'll use a virtual bytecode interpreter)
(which we can implement in any language)
* disassembler (unused)
# probably want a disassembler if I reorder the opcodes, or for a debugger
# but probably don't need this for the bootstrapping process
** program to generate hex dump of tos
** break off a digit
#+begin_src b4a

:nibl (x-xd)  # extract next nibble
du si 0F an   # x → xx → xxF → xd  (where d=x & F)
sw si 04 sr   # xd → dx → dx'      (where x'=x>>4)
rt .. .. ..
#+end_src

** break off all 8 digits
: jump, loop, or macro, or duplicate code ?
#+begin_src b4a
# break tos into 8 hex digits
dusi0Fanswsi04sr dusi0Fanswsi04sr dusi0Fanswsi04sr dusi0Fanswsi04sr
dusi0Fanswsi04sr dusi0Fanswsi04sr dusi0Fanswsi04sr dusi0Fanswsi04sr
zp

# or, if we can call subroutines:
nibl nibl nibl nibl nibl nibl nibl nibl zap

# or
&nibl 8 times zap

# or:
#+end_src

- we could just repeat the instructions 4 times without the return.
- or we could use a loop

** 0..f -> char
char buf
just use it as index into buffer

* TODO [2/6] extra control structures
** TODO =ef= for 'else if' ... maybe this is just =el=, since =if= is a no-op?
** TODO fn : implementing function arguments
- op 'ac s' would specify up to four arguments
  - s would be a signature byte
    - 2 bits specify number of args (up to 4)
    - 4 bits specify which ones to preserve
    - 2 bits left over for some other purprose
      - ex: you could pass up to 16 arguments, only the last 4 could be writable
      - but you probably just don't need this.
      - you might want 1 bit for 'is recursive'. (see below)
  - inside the definition, allocate n cells
  - push the first n control registers to the return stack
  - (if the function is recursive, you also have to push the cells onto the return stack)
  - set ^A to address of first cell, ^B to next, etc.
  - move the four values from the stack to the cells
  - now inside the function, you can use ^A ^B ^C ^D to refer to the args.
  - before returning, restore the arguments
- all this means more work as part of the protocol, but less stack juggling
** TODO =rp .. un= : repeat until
** TODO =case= case / switch statement for scalars
- with or without fallthrough (no fallthrough means you can reorder)
- with range matching
* impleminting some ops in b3a
** DONE implementing =nx= if it weren't an opcode
![ rd si 01 sb du !]  (leaving two copies of (ii-1))
![ h0 03 !]           (if 0, hop over the next 3 bytes)
![ dr hp !] zw        (>0, so put back on return stack and hop backwards)
![ zp !]              (zap extra 0 at runtime)

** DONE =!b= ('wb' when I only had 'wm') writes a single byte to an address, while preserving Z
 sw (ab-ba)
 zd (.. baz)
 sw (.. bza)
 dz (.. bz) and Z'=a
 sw (.. zb)
 zw (.. z) and M[a]=b
 dz (.. ) restoring Z
* bibliography
** [APTOP] eric hehner, [[http://www.cs.toronto.edu/~hehner/aPToP/][a practical theory of programming]]
:PROPERTIES:
:CUSTOM_ID: aptop
:END:

** edmund grimley evans, [[http://web.archive.org/web/20061108010907/http://www.rano.org/bcompiler.html][bootstrapping a simple compiler from nothing]]
** jonesforth
** retroforth
** kragen sitaker, [[https://github.com/kragen/stoneknifeforth][stone knife forth]] uses a 1-char instruction set

* stackwise approach
- keep it simple: b4-specific for now
- at the top level, you enter a specification
  - a specification is a description of behavior
- definitions only need to be well defined and valid syntax
  - wds =                           -- well defined spec
    - | 'ok'
    - | (var) ':=' (val)
    - | (wds) .. (wds)
    - |  if: (cond) do: (wds)
        (ef: (cond) do: (exp))*
        (el: (exp))? nd.
    - | wh: (cond) do: (wds) en.
    - | fo: (var) in: (exp) do. (wds) en.
    - | (other combinators: @ & ^: etc )

  - also need: definitions for data types, 'classes'

- usage:
  - enter as many type specs as you like
    - obligation: valid syntax,
    - obligation: all referenced names are defined
  - enter as many examples as you like (become test cases)
  - enter a function name
  - give it a name, and that's the first word you have to define
- this generates several obligations:
  - define (specify) all undefined words
  - prove that the word implements the spec
  - implement all unimplemented words
    - can specify these without implementation (for now)
